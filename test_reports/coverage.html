
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agentic: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/coder/coder/v2/agentic/agent.go (0.0%)</option>
				
				<option value="file1">github.com/coder/coder/v2/agentic/auth.go (0.0%)</option>
				
				<option value="file2">github.com/coder/coder/v2/agentic/cmd/example/main.go (0.0%)</option>
				
				<option value="file3">github.com/coder/coder/v2/agentic/config.go (0.0%)</option>
				
				<option value="file4">github.com/coder/coder/v2/agentic/connector_agentzero.go (0.0%)</option>
				
				<option value="file5">github.com/coder/coder/v2/agentic/connector_docker.go (0.0%)</option>
				
				<option value="file6">github.com/coder/coder/v2/agentic/connector_gpu.go (0.0%)</option>
				
				<option value="file7">github.com/coder/coder/v2/agentic/connector_hf.go (0.0%)</option>
				
				<option value="file8">github.com/coder/coder/v2/agentic/connector_ioi.go (0.0%)</option>
				
				<option value="file9">github.com/coder/coder/v2/agentic/connector_kubernetes.go (0.0%)</option>
				
				<option value="file10">github.com/coder/coder/v2/agentic/connector_nix.go (0.0%)</option>
				
				<option value="file11">github.com/coder/coder/v2/agentic/connector_opencode.go (0.0%)</option>
				
				<option value="file12">github.com/coder/coder/v2/agentic/connector_proxmox.go (0.0%)</option>
				
				<option value="file13">github.com/coder/coder/v2/agentic/example.go (0.0%)</option>
				
				<option value="file14">github.com/coder/coder/v2/agentic/example_gpu.go (0.0%)</option>
				
				<option value="file15">github.com/coder/coder/v2/agentic/example_infrastructure.go (0.0%)</option>
				
				<option value="file16">github.com/coder/coder/v2/agentic/example_nix.go (0.0%)</option>
				
				<option value="file17">github.com/coder/coder/v2/agentic/gpu_tools.go (0.0%)</option>
				
				<option value="file18">github.com/coder/coder/v2/agentic/orchestrator.go (0.0%)</option>
				
				<option value="file19">github.com/coder/coder/v2/agentic/secrets.go (0.0%)</option>
				
				<option value="file20">github.com/coder/coder/v2/agentic/task.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package agentic provides a lightweight agent/task system for agentic tools and LLM connectors.
package agentic

import (
        "context"
        "sync"

        "golang.org/x/xerrors"
)

// Agent defines the interface for agentic tools (LLM, embedding, etc).
type Agent interface {
        Name() string
        Supports(taskType string) bool
        Execute(ctx context.Context, task *Task) (*TaskResult, error)
}

// Registry manages agent registration and selection.
type Registry struct {
        mu     sync.RWMutex
        agents []Agent
}

func NewRegistry() *Registry <span class="cov0" title="0">{
        return &amp;Registry{}
}</span>

func (r *Registry) Register(agent Agent) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.agents = append(r.agents, agent)
}</span>

func (r *Registry) Select(taskType string) (Agent, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        for _, a := range r.agents </span><span class="cov0" title="0">{
                if a.Supports(taskType) </span><span class="cov0" title="0">{
                        return a, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, xerrors.New("no agent supports task type: " + taskType)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package agentic provides FOSS GitHub OAuth authentication for the agentic orchestration system.
package agentic

import (
        "context"
        "crypto/rand"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "golang.org/x/xerrors"

        "golang.org/x/oauth2"
        "golang.org/x/oauth2/github"
)

// GitHubUser represents a GitHub user from the API.
type GitHubUser struct {
        ID        int64  `json:"id"`
        Login     string `json:"login"`
        Name      string `json:"name"`
        Email     string `json:"email"`
        AvatarURL string `json:"avatar_url"`
}

// AuthSession represents an authenticated user session.
type AuthSession struct {
        UserID       string    `json:"user_id"`
        Login        string    `json:"login"`
        Email        string    `json:"email"`
        Name         string    `json:"name"`
        AvatarURL    string    `json:"avatar_url"`
        Token        string    `json:"token"`
        RefreshToken string    `json:"refresh_token,omitempty"`
        Expires      time.Time `json:"expires"`
        CreatedAt    time.Time `json:"created_at"`
}

// GitHubAuthConfig holds GitHub OAuth configuration.
type GitHubAuthConfig struct {
        ClientID     string
        ClientSecret string
        RedirectURL  string
        Scopes       []string
}

// GitHubAuthProvider implements GitHub OAuth2 authentication using FOSS libraries.
type GitHubAuthProvider struct {
        config      *oauth2.Config
        secretStore SecretStore
        sessions    map[string]*AuthSession // In-memory session store (production should use Redis/DB)
        logger      func(string, ...interface{})
}

// NewGitHubAuthProvider creates a new GitHub OAuth provider.
func NewGitHubAuthProvider(cfg GitHubAuthConfig, secretStore SecretStore) *GitHubAuthProvider <span class="cov0" title="0">{
        if len(cfg.Scopes) == 0 </span><span class="cov0" title="0">{
                cfg.Scopes = []string{"user:email", "read:user"}
        }</span>

        <span class="cov0" title="0">oauthConfig := &amp;oauth2.Config{
                ClientID:     cfg.ClientID,
                ClientSecret: cfg.ClientSecret,
                RedirectURL:  cfg.RedirectURL,
                Scopes:       cfg.Scopes,
                Endpoint:     github.Endpoint,
        }

        return &amp;GitHubAuthProvider{
                config:      oauthConfig,
                secretStore: secretStore,
                sessions:    make(map[string]*AuthSession),
        }</span>
}

// SetLogger sets a logger function for the auth provider.
func (g *GitHubAuthProvider) SetLogger(logger func(string, ...interface{})) <span class="cov0" title="0">{
        g.logger = logger
}</span>

// GenerateAuthURL generates a GitHub OAuth authorization URL with state parameter.
func (g *GitHubAuthProvider) GenerateAuthURL(state string) (string, error) <span class="cov0" title="0">{
        if state == "" </span><span class="cov0" title="0">{
                // Generate a random state if none provided
                b := make([]byte, 32)
                if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                        return "", xerrors.Errorf("failed to generate state: %w", err)
                }</span>
                <span class="cov0" title="0">state = base64.URLEncoding.EncodeToString(b)</span>
        }

        <span class="cov0" title="0">url := g.config.AuthCodeURL(state, oauth2.AccessTypeOffline)

        if g.logger != nil </span><span class="cov0" title="0">{
                g.logger("Generated GitHub auth URL with state: %s", state)
        }</span>

        <span class="cov0" title="0">return url, nil</span>
}

// HandleCallback handles the OAuth callback and exchanges code for token.
func (g *GitHubAuthProvider) HandleCallback(ctx context.Context, code, state string) (*AuthSession, error) <span class="cov0" title="0">{
        if g.logger != nil </span><span class="cov0" title="0">{
                g.logger("Handling GitHub OAuth callback with code and state")
        }</span>

        // Exchange authorization code for token
        <span class="cov0" title="0">token, err := g.config.Exchange(ctx, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to exchange code for token: %w", err)
        }</span>

        // Get user information from GitHub API
        <span class="cov0" title="0">user, err := g.fetchGitHubUser(ctx, token.AccessToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to fetch user info: %w", err)
        }</span>

        // Create session
        <span class="cov0" title="0">session := &amp;AuthSession{
                UserID:       fmt.Sprintf("%d", user.ID),
                Login:        user.Login,
                Email:        user.Email,
                Name:         user.Name,
                AvatarURL:    user.AvatarURL,
                Token:        token.AccessToken,
                RefreshToken: token.RefreshToken,
                Expires:      token.Expiry,
                CreatedAt:    time.Now(),
        }

        // Store session (in production, use persistent storage)
        sessionID := g.generateSessionID()
        g.sessions[sessionID] = session

        // Optionally store user token securely
        if g.secretStore != nil </span><span class="cov0" title="0">{
                tokenKey := fmt.Sprintf("github_token_%s", user.Login)
                if err := g.secretStore.Set(tokenKey, token.AccessToken); err != nil </span><span class="cov0" title="0">{
                        if g.logger != nil </span><span class="cov0" title="0">{
                                g.logger("Warning: Failed to store GitHub token for user %s: %v", user.Login, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">if g.logger != nil </span><span class="cov0" title="0">{
                g.logger("Successfully authenticated GitHub user: %s (%s)", user.Login, user.Email)
        }</span>

        <span class="cov0" title="0">return session, nil</span>
}

// fetchGitHubUser fetches user information from GitHub API.
func (g *GitHubAuthProvider) fetchGitHubUser(ctx context.Context, accessToken string) (*GitHubUser, error) <span class="cov0" title="0">{
        client := &amp;http.Client{Timeout: 10 * time.Second}

        req, err := http.NewRequestWithContext(ctx, "GET", "https://api.github.com/user", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+accessToken)
        req.Header.Set("Accept", "application/vnd.github.v3+json")

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("GitHub API returned status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var user GitHubUser
        if err := json.NewDecoder(resp.Body).Decode(&amp;user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fetch user email if not included in user object
        <span class="cov0" title="0">if user.Email == "" </span><span class="cov0" title="0">{
                email, err := g.fetchGitHubUserEmail(ctx, accessToken)
                if err == nil </span><span class="cov0" title="0">{
                        user.Email = email
                }</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// fetchGitHubUserEmail fetches the primary email from GitHub API.
func (g *GitHubAuthProvider) fetchGitHubUserEmail(ctx context.Context, accessToken string) (string, error) <span class="cov0" title="0">{
        client := &amp;http.Client{Timeout: 10 * time.Second}

        req, err := http.NewRequestWithContext(ctx, "GET", "https://api.github.com/user/emails", nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+accessToken)
        req.Header.Set("Accept", "application/vnd.github.v3+json")

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", xerrors.Errorf("GitHub API returned status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var emails []struct {
                Email   string `json:"email"`
                Primary bool   `json:"primary"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;emails); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">for _, email := range emails </span><span class="cov0" title="0">{
                if email.Primary </span><span class="cov0" title="0">{
                        return email.Email, nil
                }</span>
        }

        <span class="cov0" title="0">if len(emails) &gt; 0 </span><span class="cov0" title="0">{
                return emails[0].Email, nil
        }</span>

        <span class="cov0" title="0">return "", xerrors.New("no email found")</span>
}

// generateSessionID generates a secure session ID.
func (g *GitHubAuthProvider) generateSessionID() string <span class="cov0" title="0">{
        b := make([]byte, 32)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                // Fallback to timestamp-based ID
                return fmt.Sprintf("session_%d", time.Now().UnixNano())
        }</span>
        <span class="cov0" title="0">return base64.URLEncoding.EncodeToString(b)</span>
}

// GetSession retrieves a session by ID.
func (g *GitHubAuthProvider) GetSession(sessionID string) (*AuthSession, bool) <span class="cov0" title="0">{
        session, exists := g.sessions[sessionID]
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Check if session is expired
        <span class="cov0" title="0">if time.Now().After(session.Expires) </span><span class="cov0" title="0">{
                delete(g.sessions, sessionID)
                return nil, false
        }</span>

        <span class="cov0" title="0">return session, true</span>
}

// RevokeSession removes a session.
func (g *GitHubAuthProvider) RevokeSession(sessionID string) <span class="cov0" title="0">{
        delete(g.sessions, sessionID)
}</span>

// RefreshToken refreshes an expired access token using the refresh token.
func (g *GitHubAuthProvider) RefreshToken(ctx context.Context, refreshToken string) (*oauth2.Token, error) <span class="cov0" title="0">{
        token := &amp;oauth2.Token{
                RefreshToken: refreshToken,
        }

        tokenSource := g.config.TokenSource(ctx, token)
        newToken, err := tokenSource.Token()
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to refresh token: %w", err)
        }</span>

        <span class="cov0" title="0">return newToken, nil</span>
}

// AuthMiddleware creates HTTP middleware for authentication.
func (g *GitHubAuthProvider) AuthMiddleware() func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Extract session from cookie or header
                        sessionID := r.Header.Get("X-Session-ID")
                        if sessionID == "" </span><span class="cov0" title="0">{
                                if cookie, err := r.Cookie("session_id"); err == nil </span><span class="cov0" title="0">{
                                        sessionID = cookie.Value
                                }</span>
                        }

                        <span class="cov0" title="0">if sessionID == "" </span><span class="cov0" title="0">{
                                http.Error(w, "Authentication required", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov0" title="0">session, exists := g.GetSession(sessionID)
                        if !exists </span><span class="cov0" title="0">{
                                http.Error(w, "Invalid or expired session", http.StatusUnauthorized)
                                return
                        }</span>

                        // Add session to request context
                        <span class="cov0" title="0">ctx := context.WithValue(r.Context(), "session", session)
                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                })
        }
}

// GetUserFromContext extracts the authenticated user from request context.
func GetUserFromContext(ctx context.Context) (*AuthSession, bool) <span class="cov0" title="0">{
        session, ok := ctx.Value("session").(*AuthSession)
        return session, ok
}</span>

// AuthHandler creates HTTP handlers for OAuth flow.
type AuthHandler struct {
        provider *GitHubAuthProvider
        logger   func(string, ...interface{})
}

// NewAuthHandler creates a new auth handler.
func NewAuthHandler(provider *GitHubAuthProvider) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{
                provider: provider,
        }
}</span>

// SetLogger sets a logger function.
func (ah *AuthHandler) SetLogger(logger func(string, ...interface{})) <span class="cov0" title="0">{
        ah.logger = logger
}</span>

// LoginHandler handles the OAuth login initiation.
func (ah *AuthHandler) LoginHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        state := r.URL.Query().Get("state")

        authURL, err := ah.provider.GenerateAuthURL(state)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to generate auth URL", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">http.Redirect(w, r, authURL, http.StatusTemporaryRedirect)</span>
}

// CallbackHandler handles the OAuth callback.
func (ah *AuthHandler) CallbackHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        code := r.URL.Query().Get("code")
        state := r.URL.Query().Get("state")

        if code == "" </span><span class="cov0" title="0">{
                http.Error(w, "Authorization code not provided", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">session, err := ah.provider.HandleCallback(r.Context(), code, state)
        if err != nil </span><span class="cov0" title="0">{
                if ah.logger != nil </span><span class="cov0" title="0">{
                        ah.logger("OAuth callback error: %v", err)
                }</span>
                <span class="cov0" title="0">http.Error(w, "Authentication failed", http.StatusInternalServerError)
                return</span>
        }

        // Set session cookie
        <span class="cov0" title="0">sessionID := ""
        for id, sess := range ah.provider.sessions </span><span class="cov0" title="0">{
                if sess == session </span><span class="cov0" title="0">{
                        sessionID = id
                        break</span>
                }
        }

        <span class="cov0" title="0">http.SetCookie(w, &amp;http.Cookie{
                Name:     "session_id",
                Value:    sessionID,
                Path:     "/",
                HttpOnly: true,
                Secure:   r.TLS != nil,
                SameSite: http.SameSiteLaxMode,
                Expires:  session.Expires,
        })

        // Return user info as JSON
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
                "user": map[string]interface{}{
                        "id":         session.UserID,
                        "login":      session.Login,
                        "email":      session.Email,
                        "name":       session.Name,
                        "avatar_url": session.AvatarURL,
                },
        })</span>
}

// LogoutHandler handles user logout.
func (ah *AuthHandler) LogoutHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        sessionID := r.Header.Get("X-Session-ID")
        if sessionID == "" </span><span class="cov0" title="0">{
                if cookie, err := r.Cookie("session_id"); err == nil </span><span class="cov0" title="0">{
                        sessionID = cookie.Value
                }</span>
        }

        <span class="cov0" title="0">if sessionID != "" </span><span class="cov0" title="0">{
                ah.provider.RevokeSession(sessionID)
        }</span>

        // Clear session cookie
        <span class="cov0" title="0">http.SetCookie(w, &amp;http.Cookie{
                Name:     "session_id",
                Value:    "",
                Path:     "/",
                HttpOnly: true,
                Secure:   r.TLS != nil,
                SameSite: http.SameSiteLaxMode,
                Expires:  time.Unix(0, 0),
        })

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
                "message": "Logged out successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"

        "github.com/coder/coder/v2/agentic"
)

func main() <span class="cov0" title="0">{
        addr := os.Getenv("AGENTIC_EXAMPLE_ADDR")
        if addr == "" </span><span class="cov0" title="0">{
                addr = ":8080"
        }</span>
        <span class="cov0" title="0">server, err := agentic.NewExampleServer()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create example server: %v", err)
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle graceful shutdown
        stop := make(chan os.Signal, 1)
        signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)
        go func() </span><span class="cov0" title="0">{
                &lt;-stop
                log.Println("Shutting down agentic example server...")
                cancel()
        }</span>()

        <span class="cov0" title="0">if err := server.Start(ctx, addr); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                log.Fatalf("Server exited with error: %v", err)
        }</span>
        <span class="cov0" title="0">log.Println("Agentic example server stopped gracefully")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package agentic provides configuration for agentic connectors.
package agentic

import (
        "strings"
)

// Config holds API keys and model selection for all connectors.
type Config struct {
        HuggingFace    HFConfig
        IOIntelligence IOIConfig
        OpenCode       OpenCodeConfig
        AgentZero      AgentZeroConfig
        DefaultLLM     string // "huggingface" or "io_intelligence" or "opencode"
        DefaultEmbed   string // "huggingface" or "io_intelligence" or "opencode"

        // Authentication configuration
        Auth AuthConfig `json:"auth" yaml:"auth"`

        // Secrets management configuration
        Secrets SecretsConfig `json:"secrets" yaml:"secrets"`

        // Infrastructure configuration
        Infrastructure InfrastructureConfig `json:"infrastructure" yaml:"infrastructure"`
}

// AuthConfig holds authentication configuration.
type AuthConfig struct {
        GitHub GitHubAuthConfig `json:"github" yaml:"github"`
}

// SecretsConfig holds secrets management configuration.
type SecretsConfig struct {
        // Primary secret store type: "env", "file", "vault", "k8s"
        Provider string `json:"provider" yaml:"provider"`

        // File-based secrets configuration
        File FileSecretsConfig `json:"file" yaml:"file"`

        // Vault configuration (for future implementation)
        Vault VaultConfig `json:"vault" yaml:"vault"`

        // Kubernetes secrets configuration (for future implementation)
        Kubernetes K8sSecretsConfig `json:"kubernetes" yaml:"kubernetes"`
}

// FileSecretsConfig holds file-based secrets configuration.
type FileSecretsConfig struct {
        Path     string `json:"path" yaml:"path"`
        Password string `json:"password" yaml:"password"` // Should be set via env var
}

// VaultConfig holds HashiCorp Vault configuration.
type VaultConfig struct {
        Address string `json:"address" yaml:"address"`
        Token   string `json:"token" yaml:"token"`
        Path    string `json:"path" yaml:"path"`
}

// K8sSecretsConfig holds Kubernetes secrets configuration.
type K8sSecretsConfig struct {
        Namespace string `json:"namespace" yaml:"namespace"`
        Name      string `json:"name" yaml:"name"`
}

// NixConfig holds Nix/NixOS configuration.
type NixConfig struct {
        NixPath       string            `json:"nix_path"`       // Custom NIX_PATH
        RemoteBuilds  bool              `json:"remote_builds"`  // Enable remote builds
        Substitutes   []string          `json:"substitutes"`    // Binary cache substitutes
        TrustedKeys   []string          `json:"trusted_keys"`   // Trusted public keys for cache
        FlakesEnabled bool              `json:"flakes_enabled"` // Enable flakes support
        RemoteHosts   []NixRemoteHost   `json:"remote_hosts"`   // Remote NixOS machines
        SigningKey    string            `json:"signing_key"`    // Store signing key path
        ExtraConfig   map[string]string `json:"extra_config"`   // Additional nix.conf settings
}

// NixRemoteHost represents a remote NixOS machine.
type NixRemoteHost struct {
        Name       string `json:"name"`
        Host       string `json:"host"`
        User       string `json:"user"`
        SSHKey     string `json:"ssh_key"`
        SystemType string `json:"system_type"` // x86_64-linux, aarch64-linux, etc.
        MaxJobs    int    `json:"max_jobs"`
}

// InfrastructureConfig holds infrastructure connector configurations.
type InfrastructureConfig struct {
        Proxmox    ProxmoxConfig    `json:"proxmox" yaml:"proxmox"`
        Docker     DockerConfig     `json:"docker" yaml:"docker"`
        Kubernetes KubernetesConfig `json:"kubernetes" yaml:"kubernetes"`
        Nix        NixConfig        `json:"nix" yaml:"nix"`
        GPU        GPUConfig        `json:"gpu" yaml:"gpu"`
}

// DefaultConfig returns a default configuration with secure defaults.
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                DefaultLLM:   "huggingface",
                DefaultEmbed: "huggingface",
                OpenCode:     OpenCodeConfig{},
                AgentZero:    AgentZeroConfig{},
                Auth: AuthConfig{
                        GitHub: GitHubAuthConfig{
                                Scopes: []string{"user:email", "read:user"},
                        },
                },
                Secrets: SecretsConfig{
                        Provider: "env", // Default to environment variables
                        File: FileSecretsConfig{
                                Path: ".agentic/secrets.json",
                        },
                },
                Infrastructure: InfrastructureConfig{
                        Docker: DockerConfig{
                                Engine: "docker",
                        },
                        Kubernetes: KubernetesConfig{
                                Engine: "kubectl",
                        },
                        GPU: GPUConfig{
                                NvidiaSMIPath:    "nvidia-smi",
                                DockerRuntime:    "nvidia",
                                EnableMonitoring: false,
                                MaxGPUsPerTask:   8,
                        },
                },
        }
}</span>

/*
 * LoadFromSecrets populates configuration values from the secret manager.
 * Also loads OpenCode and Agent-Zero config.
 */
func (c *Config) LoadFromSecrets(secretManager *SecretManager) error <span class="cov0" title="0">{
        // Load GitHub OAuth credentials
        if clientID, err := secretManager.Get("GITHUB_CLIENT_ID"); err == nil </span><span class="cov0" title="0">{
                c.Auth.GitHub.ClientID = clientID
        }</span>

        <span class="cov0" title="0">if clientSecret, err := secretManager.Get("GITHUB_CLIENT_SECRET"); err == nil </span><span class="cov0" title="0">{
                c.Auth.GitHub.ClientSecret = clientSecret
        }</span>

        <span class="cov0" title="0">if redirectURL, err := secretManager.Get("GITHUB_REDIRECT_URL"); err == nil </span><span class="cov0" title="0">{
                c.Auth.GitHub.RedirectURL = redirectURL
        }</span>

        // Load HuggingFace API key
        <span class="cov0" title="0">if apiKey, err := secretManager.Get("HUGGINGFACE_API_KEY"); err == nil </span><span class="cov0" title="0">{
                c.HuggingFace.APIKey = apiKey
        }</span>

        // Load IOI API key
        <span class="cov0" title="0">if apiKey, err := secretManager.Get("IO_INTELLIGENCE_API_KEY"); err == nil </span><span class="cov0" title="0">{
                c.IOIntelligence.APIKey = apiKey
        }</span>

        // Load OpenCode config
        <span class="cov0" title="0">if apiKey, err := secretManager.Get("OPENCODE_API_KEY"); err == nil </span><span class="cov0" title="0">{
                c.OpenCode.APIKey = apiKey
        }</span>
        <span class="cov0" title="0">if endpoint, err := secretManager.Get("OPENCODE_ENDPOINT"); err == nil </span><span class="cov0" title="0">{
                c.OpenCode.Endpoint = endpoint
        }</span>
        <span class="cov0" title="0">if wsurl, err := secretManager.Get("OPENCODE_WS_URL"); err == nil </span><span class="cov0" title="0">{
                c.OpenCode.WSURL = wsurl
        }</span>

        // Load Agent-Zero config
        <span class="cov0" title="0">if endpoint, err := secretManager.Get("AGENTZERO_ENDPOINT"); err == nil </span><span class="cov0" title="0">{
                c.AgentZero.Endpoint = endpoint
        }</span>
        <span class="cov0" title="0">if apiKey, err := secretManager.Get("AGENTZERO_API_KEY"); err == nil </span><span class="cov0" title="0">{
                c.AgentZero.APIKey = apiKey
        }</span>

        // Load infrastructure credentials
        <span class="cov0" title="0">if proxmoxURL, err := secretManager.Get("PROXMOX_URL"); err == nil </span><span class="cov0" title="0">{
                c.Infrastructure.Proxmox.URL = proxmoxURL
        }</span>

        <span class="cov0" title="0">if proxmoxUsername, err := secretManager.Get("PROXMOX_USERNAME"); err == nil </span><span class="cov0" title="0">{
                c.Infrastructure.Proxmox.Username = proxmoxUsername
        }</span>

        <span class="cov0" title="0">if proxmoxPassword, err := secretManager.Get("PROXMOX_PASSWORD"); err == nil </span><span class="cov0" title="0">{
                c.Infrastructure.Proxmox.Password = proxmoxPassword
        }</span>

        <span class="cov0" title="0">if proxmoxToken, err := secretManager.Get("PROXMOX_TOKEN"); err == nil </span><span class="cov0" title="0">{
                c.Infrastructure.Proxmox.Token = proxmoxToken
        }</span>

        <span class="cov0" title="0">if proxmoxNode, err := secretManager.Get("PROXMOX_NODE"); err == nil </span><span class="cov0" title="0">{
                c.Infrastructure.Proxmox.Node = proxmoxNode
        }</span>

        // Load Docker configuration
        <span class="cov0" title="0">if dockerHost, err := secretManager.Get("DOCKER_HOST"); err == nil </span><span class="cov0" title="0">{
                c.Infrastructure.Docker.Host = dockerHost
        }</span>

        <span class="cov0" title="0">if certPath, err := secretManager.Get("DOCKER_CERT_PATH"); err == nil </span><span class="cov0" title="0">{
                c.Infrastructure.Docker.CertPath = certPath
        }</span>

        // Load Kubernetes configuration
        <span class="cov0" title="0">if kubeconfig, err := secretManager.Get("KUBECONFIG"); err == nil </span><span class="cov0" title="0">{
                c.Infrastructure.Kubernetes.Kubeconfig = kubeconfig
        }</span>

        <span class="cov0" title="0">if k8sContext, err := secretManager.Get("KUBE_CONTEXT"); err == nil </span><span class="cov0" title="0">{
                c.Infrastructure.Kubernetes.Context = k8sContext
        }</span>

        <span class="cov0" title="0">if k8sNamespace, err := secretManager.Get("KUBE_NAMESPACE"); err == nil </span><span class="cov0" title="0">{
                c.Infrastructure.Kubernetes.Namespace = k8sNamespace
        }</span>

        // Load Nix configuration
        <span class="cov0" title="0">if nixPath, err := secretManager.Get("NIX_PATH"); err == nil </span><span class="cov0" title="0">{
                c.Infrastructure.Nix.NixPath = nixPath
        }</span>

        <span class="cov0" title="0">if signingKey, err := secretManager.Get("NIX_SIGNING_KEY"); err == nil </span><span class="cov0" title="0">{
                c.Infrastructure.Nix.SigningKey = signingKey
        }</span>

        <span class="cov0" title="0">if substitutes, err := secretManager.Get("NIX_SUBSTITUTES"); err == nil </span><span class="cov0" title="0">{
                c.Infrastructure.Nix.Substitutes = strings.Split(substitutes, ",")
        }</span>

        <span class="cov0" title="0">if trustedKeys, err := secretManager.Get("NIX_TRUSTED_KEYS"); err == nil </span><span class="cov0" title="0">{
                c.Infrastructure.Nix.TrustedKeys = strings.Split(trustedKeys, ",")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package agentic provides an Agent-Zero orchestrator connector.
package agentic

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "io"
        "log"
        "net/http"
        "sync"
        "time"
)

// AgentZeroConfig holds Agent-Zero API config.
type AgentZeroConfig struct {
        Endpoint string // JSON-RPC/HTTP endpoint, e.g. https://agentzero.local/api/jsonrpc
        APIKey   string
}

// AgentZeroClient implements the Agent interface for Agent-Zero orchestration.
type AgentZeroClient struct {
        cfg    AgentZeroConfig
        memory sync.Map // simple in-memory state for demonstration
}

func NewAgentZeroClient(cfg AgentZeroConfig) *AgentZeroClient <span class="cov0" title="0">{
        return &amp;AgentZeroClient{cfg: cfg}
}</span>

func (a *AgentZeroClient) Name() string <span class="cov0" title="0">{ return "agent-zero" }</span>

func (a *AgentZeroClient) Supports(taskType string) bool <span class="cov0" title="0">{
        return taskType == "agent-zero" || taskType == "orchestration" || taskType == "workflow"
}</span>

func (a *AgentZeroClient) Execute(ctx context.Context, task *Task) (*TaskResult, error) <span class="cov0" title="0">{
        endpoint := a.cfg.Endpoint
        if endpoint == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Agent-Zero endpoint not configured")
        }</span>
        // JSON-RPC 2.0 request
        <span class="cov0" title="0">reqBody := map[string]interface{}{
                "jsonrpc": "2.0",
                "method":  "orchestrate",
                "params":  task.Payload,
                "id":      time.Now().UnixNano(),
        }
        payload, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[agent-zero] marshal error: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", endpoint, bytes.NewReader(payload))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[agent-zero] request error: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+a.cfg.APIKey)
        req.Header.Set("Content-Type", "application/json")
        client := &amp;http.Client{Timeout: 90 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[agent-zero] http error: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        body, _ := io.ReadAll(resp.Body)
        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                log.Printf("[agent-zero] API error: %s", string(body))
                return &amp;TaskResult{Error: errors.New(string(body))}, nil
        }</span>
        <span class="cov0" title="0">var rpcResp struct {
                Result interface{} `json:"result"`
                Error  interface{} `json:"error"`
        }
        if err := json.Unmarshal(body, &amp;rpcResp); err != nil </span><span class="cov0" title="0">{
                return &amp;TaskResult{Output: string(body)}, nil
        }</span>
        <span class="cov0" title="0">if rpcResp.Error != nil </span><span class="cov0" title="0">{
                return &amp;TaskResult{Error: errors.New("Agent-Zero error")}, nil
        }</span>
        <span class="cov0" title="0">return &amp;TaskResult{Output: rpcResp.Result}, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package agentic provides Docker and Podman connector for container orchestration.
package agentic

import (
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "os/exec"
        "strings"
        "time"

        "golang.org/x/xerrors"
)

// DockerConfig holds Docker/Podman configuration.
type DockerConfig struct {
        Engine   string `json:"engine"`   // "docker" or "podman"
        Host     string `json:"host"`     // Docker host (optional)
        TLS      bool   `json:"tls"`      // Use TLS
        CertPath string `json:"certpath"` // Certificate path for TLS
}

// DockerClient is an agent for Docker/Podman container orchestration tasks.
type DockerClient struct {
        cfg DockerConfig
}

// DockerTask represents a Docker orchestration task.
type DockerTask struct {
        Action        string                 `json:"action"`     // run, build, stop, rm, ps, logs, pull, push
        Image         string                 `json:"image"`      // Container image
        Name          string                 `json:"name"`       // Container name
        Command       []string               `json:"command"`    // Command to run
        Ports         []string               `json:"ports"`      // Port mappings (e.g., "8080:80")
        Volumes       []string               `json:"volumes"`    // Volume mounts (e.g., "/host:/container")
        Env           map[string]string      `json:"env"`        // Environment variables
        Network       string                 `json:"network"`    // Network name
        Labels        map[string]string      `json:"labels"`     // Container labels
        Remove        bool                   `json:"remove"`     // Remove container when it stops
        Detach        bool                   `json:"detach"`     // Run in background
        Config        map[string]interface{} `json:"config"`     // Additional configuration
        BuildPath     string                 `json:"buildpath"`  // Build context path
        DockerfileCmd string                 `json:"dockerfile"` // Dockerfile path
        Compose       *DockerComposeTask     `json:"compose"`    // Docker Compose task
        GPUs          *DockerGPUConfig       `json:"gpus"`       // GPU configuration
}

// DockerComposeTask represents a Docker Compose task.
type DockerComposeTask struct {
        File     string            `json:"file"`     // Compose file path
        Project  string            `json:"project"`  // Project name
        Services []string          `json:"services"` // Specific services
        EnvVars  map[string]string `json:"env"`      // Environment variables
        Profiles []string          `json:"profiles"` // Compose profiles
        Override []string          `json:"override"` // Override files
}

// DockerGPUConfig represents GPU configuration for Docker containers.
type DockerGPUConfig struct {
        Enabled      bool     `json:"enabled"`      // Enable GPU support
        Runtime      string   `json:"runtime"`      // GPU runtime (nvidia, runc)
        GPUIDs       []int    `json:"gpu_ids"`      // Specific GPU IDs
        All          bool     `json:"all"`          // Use all available GPUs
        Capabilities []string `json:"capabilities"` // GPU capabilities (compute, utility, graphics)
        Memory       string   `json:"memory"`       // GPU memory limit
}

// ContainerInfo represents container information.
type ContainerInfo struct {
        ID      string            `json:"id"`
        Name    string            `json:"name"`
        Image   string            `json:"image"`
        Status  string            `json:"status"`
        Ports   []string          `json:"ports"`
        Created time.Time         `json:"created"`
        Labels  map[string]string `json:"labels"`
}

// ImageInfo represents image information.
type ImageInfo struct {
        ID      string    `json:"id"`
        Tags    []string  `json:"tags"`
        Size    int64     `json:"size"`
        Created time.Time `json:"created"`
}

// NewDockerClient creates a new Docker/Podman client.
func NewDockerClient(cfg DockerConfig) *DockerClient <span class="cov0" title="0">{
        if cfg.Engine == "" </span><span class="cov0" title="0">{
                cfg.Engine = "docker" // Default to Docker
        }</span>

        <span class="cov0" title="0">return &amp;DockerClient{cfg: cfg}</span>
}

func (d *DockerClient) Name() string <span class="cov0" title="0">{ return "docker" }</span>

func (d *DockerClient) Supports(taskType string) bool <span class="cov0" title="0">{
        return taskType == "container" || taskType == "docker" || taskType == "podman"
}</span>

func (d *DockerClient) Execute(ctx context.Context, task *Task) (*TaskResult, error) <span class="cov0" title="0">{
        // Parse task payload
        var dockerTask DockerTask
        if err := mapToStruct(task.Payload, &amp;dockerTask); err != nil </span><span class="cov0" title="0">{
                return &amp;TaskResult{Error: xerrors.Errorf("invalid task payload: %w", err)}, nil
        }</span>

        // Execute based on action
        <span class="cov0" title="0">switch dockerTask.Action </span>{
        case "run":<span class="cov0" title="0">
                result, err := d.runContainer(ctx, &amp;dockerTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "build":<span class="cov0" title="0">
                result, err := d.buildImage(ctx, &amp;dockerTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "ps", "list":<span class="cov0" title="0">
                result, err := d.listContainers(ctx, &amp;dockerTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "images":<span class="cov0" title="0">
                result, err := d.listImages(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "stop":<span class="cov0" title="0">
                result, err := d.stopContainer(ctx, &amp;dockerTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "start":<span class="cov0" title="0">
                result, err := d.startContainer(ctx, &amp;dockerTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "rm", "remove":<span class="cov0" title="0">
                result, err := d.removeContainer(ctx, &amp;dockerTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "logs":<span class="cov0" title="0">
                result, err := d.getLogs(ctx, &amp;dockerTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "pull":<span class="cov0" title="0">
                result, err := d.pullImage(ctx, &amp;dockerTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "push":<span class="cov0" title="0">
                result, err := d.pushImage(ctx, &amp;dockerTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "compose":<span class="cov0" title="0">
                result, err := d.dockerCompose(ctx, &amp;dockerTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "inspect":<span class="cov0" title="0">
                result, err := d.inspectContainer(ctx, &amp;dockerTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        default:<span class="cov0" title="0">
                return &amp;TaskResult{Error: xerrors.Errorf("unsupported action: %s", dockerTask.Action)}, nil</span>
        }
}

// runContainer runs a new container.
func (d *DockerClient) runContainer(ctx context.Context, task *DockerTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        args := []string{"run"}

        // Add options
        if task.Detach </span><span class="cov0" title="0">{
                args = append(args, "-d")
        }</span>

        <span class="cov0" title="0">if task.Remove </span><span class="cov0" title="0">{
                args = append(args, "--rm")
        }</span>

        <span class="cov0" title="0">if task.Name != "" </span><span class="cov0" title="0">{
                args = append(args, "--name", task.Name)
        }</span>

        // Add port mappings
        <span class="cov0" title="0">for _, port := range task.Ports </span><span class="cov0" title="0">{
                args = append(args, "-p", port)
        }</span>

        // Add volume mounts
        <span class="cov0" title="0">for _, volume := range task.Volumes </span><span class="cov0" title="0">{
                args = append(args, "-v", volume)
        }</span>

        // Add environment variables
        <span class="cov0" title="0">for key, value := range task.Env </span><span class="cov0" title="0">{
                args = append(args, "-e", fmt.Sprintf("%s=%s", key, value))
        }</span>

        // Add labels
        <span class="cov0" title="0">for key, value := range task.Labels </span><span class="cov0" title="0">{
                args = append(args, "--label", fmt.Sprintf("%s=%s", key, value))
        }</span>

        // Add network
        <span class="cov0" title="0">if task.Network != "" </span><span class="cov0" title="0">{
                args = append(args, "--network", task.Network)
        }</span>

        // Add GPU support
        <span class="cov0" title="0">if task.GPUs != nil &amp;&amp; task.GPUs.Enabled </span><span class="cov0" title="0">{
                if task.GPUs.All </span><span class="cov0" title="0">{
                        args = append(args, "--gpus", "all")
                }</span> else<span class="cov0" title="0"> if len(task.GPUs.GPUIDs) &gt; 0 </span><span class="cov0" title="0">{
                        gpuDevices := make([]string, len(task.GPUs.GPUIDs))
                        for i, id := range task.GPUs.GPUIDs </span><span class="cov0" title="0">{
                                gpuDevices[i] = fmt.Sprintf("device=%d", id)
                        }</span>
                        <span class="cov0" title="0">args = append(args, "--gpus", strings.Join(gpuDevices, ","))</span>
                } else<span class="cov0" title="0"> {
                        args = append(args, "--gpus", "all")
                }</span>

                // Add GPU runtime if specified
                <span class="cov0" title="0">if task.GPUs.Runtime != "" </span><span class="cov0" title="0">{
                        args = append(args, "--runtime", task.GPUs.Runtime)
                }</span>

                // Add GPU capabilities
                <span class="cov0" title="0">if len(task.GPUs.Capabilities) &gt; 0 </span><span class="cov0" title="0">{
                        caps := strings.Join(task.GPUs.Capabilities, ",")
                        // Find and modify the --gpus argument to include capabilities
                        for i, arg := range args </span><span class="cov0" title="0">{
                                if arg == "--gpus" &amp;&amp; i+1 &lt; len(args) </span><span class="cov0" title="0">{
                                        args[i+1] = fmt.Sprintf("\"%s,capabilities=%s\"", args[i+1], caps)
                                        break</span>
                                }
                        }
                }

                // Add GPU memory limit
                <span class="cov0" title="0">if task.GPUs.Memory != "" </span><span class="cov0" title="0">{
                        // This would typically be handled via --gpus options or cgroup limits
                        args = append(args, "--env", fmt.Sprintf("NVIDIA_MIG_CONFIG_DEVICES=%s", task.GPUs.Memory))
                }</span>
        }

        // Add image
        <span class="cov0" title="0">args = append(args, task.Image)

        // Add command
        if len(task.Command) &gt; 0 </span><span class="cov0" title="0">{
                args = append(args, task.Command...)
        }</span>

        <span class="cov0" title="0">output, err := d.execCommand(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to run container: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":       "run",
                "image":        task.Image,
                "name":         task.Name,
                "container_id": strings.TrimSpace(output),
        }

        return result, nil</span>
}

// buildImage builds a Docker image.
func (d *DockerClient) buildImage(ctx context.Context, task *DockerTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        args := []string{"build"}

        if task.Name != "" </span><span class="cov0" title="0">{
                args = append(args, "-t", task.Name)
        }</span>

        <span class="cov0" title="0">if task.DockerfileCmd != "" </span><span class="cov0" title="0">{
                args = append(args, "-f", task.DockerfileCmd)
        }</span>

        // Add labels
        <span class="cov0" title="0">for key, value := range task.Labels </span><span class="cov0" title="0">{
                args = append(args, "--label", fmt.Sprintf("%s=%s", key, value))
        }</span>

        // Add build context
        <span class="cov0" title="0">buildPath := task.BuildPath
        if buildPath == "" </span><span class="cov0" title="0">{
                buildPath = "."
        }</span>
        <span class="cov0" title="0">args = append(args, buildPath)

        output, err := d.execCommand(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to build image: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action": "build",
                "image":  task.Name,
                "output": output,
        }

        return result, nil</span>
}

// listContainers lists containers.
func (d *DockerClient) listContainers(ctx context.Context, task *DockerTask) ([]ContainerInfo, error) <span class="cov0" title="0">{
        args := []string{"ps", "--format", "json"}

        // Show all containers if requested
        if task.Config != nil </span><span class="cov0" title="0">{
                if all, ok := task.Config["all"].(bool); ok &amp;&amp; all </span><span class="cov0" title="0">{
                        args = append(args, "-a")
                }</span>
        }

        <span class="cov0" title="0">output, err := d.execCommand(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to list containers: %w", err)
        }</span>

        <span class="cov0" title="0">var containers []ContainerInfo
        scanner := bufio.NewScanner(strings.NewReader(output))

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var containerJSON map[string]interface{}
                if err := json.Unmarshal([]byte(line), &amp;containerJSON); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip malformed lines
                }

                <span class="cov0" title="0">container := ContainerInfo{
                        ID:     getStringField(containerJSON, "ID"),
                        Name:   getStringField(containerJSON, "Names"),
                        Image:  getStringField(containerJSON, "Image"),
                        Status: getStringField(containerJSON, "Status"),
                }

                if portsStr := getStringField(containerJSON, "Ports"); portsStr != "" </span><span class="cov0" title="0">{
                        container.Ports = strings.Split(portsStr, ", ")
                }</span>

                <span class="cov0" title="0">containers = append(containers, container)</span>
        }

        <span class="cov0" title="0">return containers, nil</span>
}

// listImages lists Docker images.
func (d *DockerClient) listImages(ctx context.Context) ([]ImageInfo, error) <span class="cov0" title="0">{
        args := []string{"images", "--format", "json"}

        output, err := d.execCommand(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to list images: %w", err)
        }</span>

        <span class="cov0" title="0">var images []ImageInfo
        scanner := bufio.NewScanner(strings.NewReader(output))

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var imageJSON map[string]interface{}
                if err := json.Unmarshal([]byte(line), &amp;imageJSON); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip malformed lines
                }

                <span class="cov0" title="0">image := ImageInfo{
                        ID:   getStringField(imageJSON, "ID"),
                        Tags: []string{getStringField(imageJSON, "Repository") + ":" + getStringField(imageJSON, "Tag")},
                }

                images = append(images, image)</span>
        }

        <span class="cov0" title="0">return images, nil</span>
}

// stopContainer stops a container.
func (d *DockerClient) stopContainer(ctx context.Context, task *DockerTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if task.Name == "" </span><span class="cov0" title="0">{
                return nil, xerrors.New("container name is required")
        }</span>

        <span class="cov0" title="0">args := []string{"stop", task.Name}

        output, err := d.execCommand(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to stop container: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action": "stop",
                "name":   task.Name,
                "output": strings.TrimSpace(output),
        }

        return result, nil</span>
}

// startContainer starts a container.
func (d *DockerClient) startContainer(ctx context.Context, task *DockerTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if task.Name == "" </span><span class="cov0" title="0">{
                return nil, xerrors.New("container name is required")
        }</span>

        <span class="cov0" title="0">args := []string{"start", task.Name}

        output, err := d.execCommand(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to start container: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action": "start",
                "name":   task.Name,
                "output": strings.TrimSpace(output),
        }

        return result, nil</span>
}

// removeContainer removes a container.
func (d *DockerClient) removeContainer(ctx context.Context, task *DockerTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if task.Name == "" </span><span class="cov0" title="0">{
                return nil, xerrors.New("container name is required")
        }</span>

        <span class="cov0" title="0">args := []string{"rm"}

        // Force removal if requested
        if task.Config != nil </span><span class="cov0" title="0">{
                if force, ok := task.Config["force"].(bool); ok &amp;&amp; force </span><span class="cov0" title="0">{
                        args = append(args, "-f")
                }</span>
        }

        <span class="cov0" title="0">args = append(args, task.Name)

        output, err := d.execCommand(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to remove container: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action": "remove",
                "name":   task.Name,
                "output": strings.TrimSpace(output),
        }

        return result, nil</span>
}

// getLogs gets container logs.
func (d *DockerClient) getLogs(ctx context.Context, task *DockerTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if task.Name == "" </span><span class="cov0" title="0">{
                return nil, xerrors.New("container name is required")
        }</span>

        <span class="cov0" title="0">args := []string{"logs"}

        // Add options from config
        if task.Config != nil </span><span class="cov0" title="0">{
                if follow, ok := task.Config["follow"].(bool); ok &amp;&amp; follow </span><span class="cov0" title="0">{
                        args = append(args, "-f")
                }</span>
                <span class="cov0" title="0">if tail, ok := task.Config["tail"].(string); ok &amp;&amp; tail != "" </span><span class="cov0" title="0">{
                        args = append(args, "--tail", tail)
                }</span>
                <span class="cov0" title="0">if since, ok := task.Config["since"].(string); ok &amp;&amp; since != "" </span><span class="cov0" title="0">{
                        args = append(args, "--since", since)
                }</span>
        }

        <span class="cov0" title="0">args = append(args, task.Name)

        output, err := d.execCommand(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to get logs: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action": "logs",
                "name":   task.Name,
                "logs":   output,
        }

        return result, nil</span>
}

// pullImage pulls a Docker image.
func (d *DockerClient) pullImage(ctx context.Context, task *DockerTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if task.Image == "" </span><span class="cov0" title="0">{
                return nil, xerrors.New("image name is required")
        }</span>

        <span class="cov0" title="0">args := []string{"pull", task.Image}

        output, err := d.execCommand(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to pull image: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action": "pull",
                "image":  task.Image,
                "output": output,
        }

        return result, nil</span>
}

// pushImage pushes a Docker image.
func (d *DockerClient) pushImage(ctx context.Context, task *DockerTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if task.Image == "" </span><span class="cov0" title="0">{
                return nil, xerrors.New("image name is required")
        }</span>

        <span class="cov0" title="0">args := []string{"push", task.Image}

        output, err := d.execCommand(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to push image: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action": "push",
                "image":  task.Image,
                "output": output,
        }

        return result, nil</span>
}

// dockerCompose executes Docker Compose commands.
func (d *DockerClient) dockerCompose(ctx context.Context, task *DockerTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if task.Compose == nil </span><span class="cov0" title="0">{
                return nil, xerrors.New("compose configuration is required")
        }</span>

        <span class="cov0" title="0">compose := task.Compose
        args := []string{"compose"}

        // Add compose file
        if compose.File != "" </span><span class="cov0" title="0">{
                args = append(args, "-f", compose.File)
        }</span>

        // Add project name
        <span class="cov0" title="0">if compose.Project != "" </span><span class="cov0" title="0">{
                args = append(args, "-p", compose.Project)
        }</span>

        // Add override files
        <span class="cov0" title="0">for _, override := range compose.Override </span><span class="cov0" title="0">{
                args = append(args, "-f", override)
        }</span>

        // Add the compose action (from main task config)
        <span class="cov0" title="0">if task.Config != nil </span><span class="cov0" title="0">{
                if action, ok := task.Config["compose_action"].(string); ok </span><span class="cov0" title="0">{
                        args = append(args, action)
                }</span> else<span class="cov0" title="0"> {
                        args = append(args, "up", "-d") // Default action
                }</span>
        } else<span class="cov0" title="0"> {
                args = append(args, "up", "-d")
        }</span>

        // Add specific services
        <span class="cov0" title="0">if len(compose.Services) &gt; 0 </span><span class="cov0" title="0">{
                args = append(args, compose.Services...)
        }</span>

        // Set environment variables
        <span class="cov0" title="0">env := make([]string, 0)
        for key, value := range compose.EnvVars </span><span class="cov0" title="0">{
                env = append(env, fmt.Sprintf("%s=%s", key, value))
        }</span>

        <span class="cov0" title="0">output, err := d.execCommandWithEnv(ctx, env, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to execute docker compose: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":  "compose",
                "project": compose.Project,
                "output":  output,
        }

        return result, nil</span>
}

// inspectContainer inspects a container.
func (d *DockerClient) inspectContainer(ctx context.Context, task *DockerTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if task.Name == "" </span><span class="cov0" title="0">{
                return nil, xerrors.New("container name is required")
        }</span>

        <span class="cov0" title="0">args := []string{"inspect", task.Name}

        output, err := d.execCommand(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to inspect container: %w", err)
        }</span>

        <span class="cov0" title="0">var inspectData []map[string]interface{}
        if err := json.Unmarshal([]byte(output), &amp;inspectData); err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to parse inspect output: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action": "inspect",
                "name":   task.Name,
                "data":   inspectData,
        }

        return result, nil</span>
}

// execCommand executes a Docker/Podman command.
func (d *DockerClient) execCommand(ctx context.Context, args ...string) (string, error) <span class="cov0" title="0">{
        return d.execCommandWithEnv(ctx, nil, args...)
}</span>

// execCommandWithEnv executes a Docker/Podman command with environment variables.
func (d *DockerClient) execCommandWithEnv(ctx context.Context, env []string, args ...string) (string, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, d.cfg.Engine, args...)

        if len(env) &gt; 0 </span><span class="cov0" title="0">{
                cmd.Env = append(cmd.Env, env...)
        }</span>

        // Add Docker host if specified
        <span class="cov0" title="0">if d.cfg.Host != "" </span><span class="cov0" title="0">{
                cmd.Env = append(cmd.Env, "DOCKER_HOST="+d.cfg.Host)
        }</span>

        // Add TLS configuration
        <span class="cov0" title="0">if d.cfg.TLS </span><span class="cov0" title="0">{
                cmd.Env = append(cmd.Env, "DOCKER_TLS_VERIFY=1")
                if d.cfg.CertPath != "" </span><span class="cov0" title="0">{
                        cmd.Env = append(cmd.Env, "DOCKER_CERT_PATH="+d.cfg.CertPath)
                }</span>
        }

        <span class="cov0" title="0">var stdout, stderr strings.Builder
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return "", xerrors.Errorf("command failed: %w, stderr: %s", err, stderr.String())
        }</span>

        <span class="cov0" title="0">return stdout.String(), nil</span>
}

// getStringField safely gets a string field from a map.
func getStringField(m map[string]interface{}, key string) string <span class="cov0" title="0">{
        if val, ok := m[key]; ok </span><span class="cov0" title="0">{
                if str, ok := val.(string); ok </span><span class="cov0" title="0">{
                        return str
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package agentic provides NVIDIA GPU connector for hardware acceleration management.
package agentic

import (
        "context"
        "fmt"
        "os/exec"
        "regexp"
        "strconv"
        "strings"
        "time"

        "golang.org/x/xerrors"
)

// GPUConfig holds GPU configuration.
type GPUConfig struct {
        NvidiaSMIPath    string `json:"nvidia_smi_path"`   // Path to nvidia-smi binary
        DockerRuntime    string `json:"docker_runtime"`    // Docker runtime for GPU support ("nvidia", "runc")
        CUDAVersion      string `json:"cuda_version"`      // Required CUDA version
        EnableMonitoring bool   `json:"enable_monitoring"` // Enable GPU monitoring
        MaxGPUsPerTask   int    `json:"max_gpus_per_task"` // Maximum GPUs per task
}

// GPUClient is an agent for NVIDIA GPU management tasks.
type GPUClient struct {
        cfg GPUConfig
}

// GPUTask represents a GPU management task.
type GPUTask struct {
        Action      string                 `json:"action"`       // detect, list, allocate, monitor, cuda-info, memory-info
        GPUIDs      []int                  `json:"gpu_ids"`      // Specific GPU IDs to target
        ContainerID string                 `json:"container_id"` // Container ID for GPU allocation
        PodName     string                 `json:"pod_name"`     // Kubernetes pod name
        Namespace   string                 `json:"namespace"`    // Kubernetes namespace
        Exclusive   bool                   `json:"exclusive"`    // Exclusive GPU allocation
        Memory      int64                  `json:"memory"`       // GPU memory requirement in MB
        Config      map[string]interface{} `json:"config"`       // Additional configuration
        Monitoring  *GPUMonitoringConfig   `json:"monitoring"`   // Monitoring configuration
}

// GPUMonitoringConfig represents GPU monitoring configuration.
type GPUMonitoringConfig struct {
        Interval     time.Duration `json:"interval"`      // Monitoring interval
        Duration     time.Duration `json:"duration"`      // Total monitoring duration
        Metrics      []string      `json:"metrics"`       // Metrics to collect
        OutputFormat string        `json:"output_format"` // json, csv, xml
}

// GPUInfo represents information about a GPU.
type GPUInfo struct {
        ID                int          `json:"id"`
        Name              string       `json:"name"`
        UUID              string       `json:"uuid"`
        PCIBusID          string       `json:"pci_bus_id"`
        DriverVersion     string       `json:"driver_version"`
        CUDAVersion       string       `json:"cuda_version"`
        MemoryTotal       int64        `json:"memory_total"`       // MB
        MemoryUsed        int64        `json:"memory_used"`        // MB
        MemoryFree        int64        `json:"memory_free"`        // MB
        UtilizationGPU    int          `json:"utilization_gpu"`    // Percentage
        UtilizationMemory int          `json:"utilization_memory"` // Percentage
        Temperature       int          `json:"temperature"`        // Celsius
        PowerDraw         float64      `json:"power_draw"`         // Watts
        PowerLimit        float64      `json:"power_limit"`        // Watts
        ClockGraphics     int          `json:"clock_graphics"`     // MHz
        ClockMemory       int          `json:"clock_memory"`       // MHz
        Processes         []GPUProcess `json:"processes"`
        Status            string       `json:"status"` // available, allocated, error
}

// GPUProcess represents a process using GPU.
type GPUProcess struct {
        PID         int    `json:"pid"`
        ProcessName string `json:"process_name"`
        MemoryUsed  int64  `json:"memory_used"` // MB
        Type        string `json:"type"`        // C (Compute), G (Graphics), C+G
}

// GPUAllocation represents a GPU allocation.
type GPUAllocation struct {
        GPUIDs      []int     `json:"gpu_ids"`
        ContainerID string    `json:"container_id,omitempty"`
        PodName     string    `json:"pod_name,omitempty"`
        Namespace   string    `json:"namespace,omitempty"`
        Exclusive   bool      `json:"exclusive"`
        AllocatedAt time.Time `json:"allocated_at"`
        MemoryLimit int64     `json:"memory_limit,omitempty"` // MB
}

// CUDAInfo represents CUDA installation information.
type CUDAInfo struct {
        Version           string   `json:"version"`
        DriverVersion     string   `json:"driver_version"`
        RuntimeVersion    string   `json:"runtime_version"`
        SupportedArchs    []string `json:"supported_architectures"`
        CUDNNVersion      string   `json:"cudnn_version,omitempty"`
        TensorRTVersion   string   `json:"tensorrt_version,omitempty"`
        InstallationPaths []string `json:"installation_paths"`
}

// NewGPUClient creates a new GPU client.
func NewGPUClient(cfg GPUConfig) *GPUClient <span class="cov0" title="0">{
        // Set sensible defaults
        if cfg.NvidiaSMIPath == "" </span><span class="cov0" title="0">{
                cfg.NvidiaSMIPath = "nvidia-smi"
        }</span>
        <span class="cov0" title="0">if cfg.DockerRuntime == "" </span><span class="cov0" title="0">{
                cfg.DockerRuntime = "nvidia"
        }</span>
        <span class="cov0" title="0">if cfg.MaxGPUsPerTask == 0 </span><span class="cov0" title="0">{
                cfg.MaxGPUsPerTask = 8
        }</span>

        <span class="cov0" title="0">return &amp;GPUClient{cfg: cfg}</span>
}

func (g *GPUClient) Name() string <span class="cov0" title="0">{ return "gpu" }</span>

func (g *GPUClient) Supports(taskType string) bool <span class="cov0" title="0">{
        return taskType == "gpu" || taskType == "nvidia" || taskType == "cuda" || taskType == "hardware"
}</span>

func (g *GPUClient) Execute(ctx context.Context, task *Task) (*TaskResult, error) <span class="cov0" title="0">{
        // Parse task payload
        var gpuTask GPUTask
        if err := mapToStruct(task.Payload, &amp;gpuTask); err != nil </span><span class="cov0" title="0">{
                return &amp;TaskResult{Error: xerrors.Errorf("invalid task payload: %w", err)}, nil
        }</span>

        // Execute based on action
        <span class="cov0" title="0">switch gpuTask.Action </span>{
        case "detect", "list":<span class="cov0" title="0">
                result, err := g.listGPUs(ctx, &amp;gpuTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "info":<span class="cov0" title="0">
                result, err := g.getGPUInfo(ctx, &amp;gpuTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "monitor":<span class="cov0" title="0">
                result, err := g.monitorGPUs(ctx, &amp;gpuTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "allocate":<span class="cov0" title="0">
                result, err := g.allocateGPUs(ctx, &amp;gpuTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "deallocate":<span class="cov0" title="0">
                result, err := g.deallocateGPUs(ctx, &amp;gpuTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "cuda-info":<span class="cov0" title="0">
                result, err := g.getCUDAInfo(ctx, &amp;gpuTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "memory-info":<span class="cov0" title="0">
                result, err := g.getMemoryInfo(ctx, &amp;gpuTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "processes":<span class="cov0" title="0">
                result, err := g.getGPUProcesses(ctx, &amp;gpuTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "topology":<span class="cov0" title="0">
                result, err := g.getGPUTopology(ctx, &amp;gpuTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "reset":<span class="cov0" title="0">
                result, err := g.resetGPUs(ctx, &amp;gpuTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        default:<span class="cov0" title="0">
                return &amp;TaskResult{Error: xerrors.Errorf("unsupported action: %s", gpuTask.Action)}, nil</span>
        }
}

// listGPUs lists all available GPUs.
func (g *GPUClient) listGPUs(ctx context.Context, task *GPUTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Check if nvidia-smi is available
        if err := g.checkNvidiaSMI(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("nvidia-smi not available: %w", err)
        }</span>

        <span class="cov0" title="0">args := []string{
                "--query-gpu=index,name,uuid,pci.bus_id,driver_version,cuda_version,memory.total,memory.used,memory.free,utilization.gpu,utilization.memory,temperature.gpu,power.draw,power.limit,clocks.current.graphics,clocks.current.memory",
                "--format=csv,noheader,nounits",
        }

        output, err := g.execNvidiaSMI(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to list GPUs: %w", err)
        }</span>

        <span class="cov0" title="0">gpus, err := g.parseGPUList(output)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to parse GPU list: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":    "list",
                "gpu_count": len(gpus),
                "gpus":      gpus,
                "timestamp": time.Now().UTC(),
        }

        return result, nil</span>
}

// getGPUInfo gets detailed information about specific GPUs.
func (g *GPUClient) getGPUInfo(ctx context.Context, task *GPUTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        var args []string

        if len(task.GPUIDs) &gt; 0 </span><span class="cov0" title="0">{
                // Query specific GPUs
                gpuIDs := make([]string, len(task.GPUIDs))
                for i, id := range task.GPUIDs </span><span class="cov0" title="0">{
                        gpuIDs[i] = strconv.Itoa(id)
                }</span>
                <span class="cov0" title="0">args = []string{
                        fmt.Sprintf("--id=%s", strings.Join(gpuIDs, ",")),
                }</span>
        }

        <span class="cov0" title="0">args = append(args, []string{
                "--query-gpu=index,name,uuid,pci.bus_id,driver_version,cuda_version,memory.total,memory.used,memory.free,utilization.gpu,utilization.memory,temperature.gpu,power.draw,power.limit,clocks.current.graphics,clocks.current.memory,compute_mode,persistence_mode",
                "--format=csv,noheader,nounits",
        }...)

        output, err := g.execNvidiaSMI(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to get GPU info: %w", err)
        }</span>

        <span class="cov0" title="0">gpus, err := g.parseDetailedGPUInfo(output)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to parse GPU info: %w", err)
        }</span>

        // Get processes for each GPU
        <span class="cov0" title="0">for i := range gpus </span><span class="cov0" title="0">{
                processes, err := g.getProcessesForGPU(ctx, gpus[i].ID)
                if err == nil </span><span class="cov0" title="0">{
                        gpus[i].Processes = processes
                }</span>
        }

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":    "info",
                "gpu_count": len(gpus),
                "gpus":      gpus,
                "timestamp": time.Now().UTC(),
        }

        return result, nil</span>
}

// monitorGPUs monitors GPU metrics over time.
func (g *GPUClient) monitorGPUs(ctx context.Context, task *GPUTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if task.Monitoring == nil </span><span class="cov0" title="0">{
                task.Monitoring = &amp;GPUMonitoringConfig{
                        Interval:     5 * time.Second,
                        Duration:     60 * time.Second,
                        Metrics:      []string{"utilization", "memory", "temperature", "power"},
                        OutputFormat: "json",
                }
        }</span>

        <span class="cov0" title="0">var samples []map[string]interface{}
        startTime := time.Now()
        ticker := time.NewTicker(task.Monitoring.Interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if time.Since(startTime) &gt;= task.Monitoring.Duration </span><span class="cov0" title="0">{
                                goto done</span>
                        }

                        // Collect sample
                        <span class="cov0" title="0">sample, err := g.collectMonitoringSample(ctx, task)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span> // Skip failed samples
                        }
                        <span class="cov0" title="0">samples = append(samples, sample)</span>

                }
        }

done:
        <span class="cov0" title="0">result := map[string]interface{}{
                "action":       "monitor",
                "start_time":   startTime.UTC(),
                "end_time":     time.Now().UTC(),
                "duration":     time.Since(startTime).String(),
                "interval":     task.Monitoring.Interval.String(),
                "sample_count": len(samples),
                "samples":      samples,
        }

        return result, nil</span>
}

// allocateGPUs allocates GPUs for a container or pod.
func (g *GPUClient) allocateGPUs(ctx context.Context, task *GPUTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Get available GPUs
        gpuListTask := &amp;GPUTask{Action: "list"}
        gpuListResult, err := g.listGPUs(ctx, gpuListTask)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to get GPU list: %w", err)
        }</span>

        <span class="cov0" title="0">gpus, ok := gpuListResult["gpus"].([]GPUInfo)
        if !ok </span><span class="cov0" title="0">{
                return nil, xerrors.New("failed to parse GPU list")
        }</span>

        // Select GPUs for allocation
        <span class="cov0" title="0">var selectedGPUs []int
        if len(task.GPUIDs) &gt; 0 </span><span class="cov0" title="0">{
                // Use specified GPUs
                selectedGPUs = task.GPUIDs
        }</span> else<span class="cov0" title="0"> {
                // Auto-select available GPUs
                for _, gpu := range gpus </span><span class="cov0" title="0">{
                        if gpu.Status == "available" &amp;&amp; len(selectedGPUs) &lt; g.cfg.MaxGPUsPerTask </span><span class="cov0" title="0">{
                                selectedGPUs = append(selectedGPUs, gpu.ID)
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(selectedGPUs) == 0 </span><span class="cov0" title="0">{
                return nil, xerrors.New("no available GPUs for allocation")
        }</span>

        <span class="cov0" title="0">allocation := GPUAllocation{
                GPUIDs:      selectedGPUs,
                ContainerID: task.ContainerID,
                PodName:     task.PodName,
                Namespace:   task.Namespace,
                Exclusive:   task.Exclusive,
                AllocatedAt: time.Now(),
                MemoryLimit: task.Memory,
        }

        result := map[string]interface{}{
                "action":     "allocate",
                "allocation": allocation,
                "gpu_count":  len(selectedGPUs),
                "gpu_ids":    selectedGPUs,
                "timestamp":  time.Now().UTC(),
        }

        return result, nil</span>
}

// deallocateGPUs deallocates GPUs from a container or pod.
func (g *GPUClient) deallocateGPUs(ctx context.Context, task *GPUTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        var deallocatedGPUs []int

        if len(task.GPUIDs) &gt; 0 </span><span class="cov0" title="0">{
                deallocatedGPUs = task.GPUIDs
        }</span> else<span class="cov0" title="0"> {
                // Find GPUs allocated to the specified container/pod
                // This would typically query an allocation database
                // For now, we'll simulate this
                deallocatedGPUs = []int{} // Would be populated from allocation tracking
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":           "deallocate",
                "deallocated_gpus": deallocatedGPUs,
                "container_id":     task.ContainerID,
                "pod_name":         task.PodName,
                "namespace":        task.Namespace,
                "timestamp":        time.Now().UTC(),
        }

        return result, nil</span>
}

// getCUDAInfo gets CUDA installation information.
func (g *GPUClient) getCUDAInfo(ctx context.Context, task *GPUTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        cudaInfo := CUDAInfo{}

        // Get CUDA version from nvidia-smi
        args := []string{"--query-gpu=cuda_version", "--format=csv,noheader,nounits"}
        output, err := g.execNvidiaSMI(ctx, args...)
        if err == nil &amp;&amp; output != "" </span><span class="cov0" title="0">{
                lines := strings.Split(strings.TrimSpace(output), "\n")
                if len(lines) &gt; 0 </span><span class="cov0" title="0">{
                        cudaInfo.Version = strings.TrimSpace(lines[0])
                }</span>
        }

        // Get driver version
        <span class="cov0" title="0">args = []string{"--query-gpu=driver_version", "--format=csv,noheader,nounits"}
        output, err = g.execNvidiaSMI(ctx, args...)
        if err == nil &amp;&amp; output != "" </span><span class="cov0" title="0">{
                lines := strings.Split(strings.TrimSpace(output), "\n")
                if len(lines) &gt; 0 </span><span class="cov0" title="0">{
                        cudaInfo.DriverVersion = strings.TrimSpace(lines[0])
                }</span>
        }

        // Try to get nvcc version
        <span class="cov0" title="0">if nvccOutput, err := g.execCommand(ctx, "nvcc", "--version"); err == nil </span><span class="cov0" title="0">{
                if re := regexp.MustCompile(`release (\d+\.\d+)`); re != nil </span><span class="cov0" title="0">{
                        if matches := re.FindStringSubmatch(nvccOutput); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                                cudaInfo.RuntimeVersion = matches[1]
                        }</span>
                }
        }

        // Check for common CUDA installation paths
        <span class="cov0" title="0">commonPaths := []string{
                "/usr/local/cuda",
                "/opt/cuda",
                "/usr/cuda",
        }

        for _, path := range commonPaths </span><span class="cov0" title="0">{
                if output, err := g.execCommand(ctx, "ls", "-d", path); err == nil &amp;&amp; strings.TrimSpace(output) != "" </span><span class="cov0" title="0">{
                        cudaInfo.InstallationPaths = append(cudaInfo.InstallationPaths, path)
                }</span>
        }

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":    "cuda-info",
                "cuda_info": cudaInfo,
                "timestamp": time.Now().UTC(),
        }

        return result, nil</span>
}

// getMemoryInfo gets detailed GPU memory information.
func (g *GPUClient) getMemoryInfo(ctx context.Context, task *GPUTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        args := []string{
                "--query-gpu=index,memory.total,memory.used,memory.free",
                "--format=csv,noheader,nounits",
        }

        if len(task.GPUIDs) &gt; 0 </span><span class="cov0" title="0">{
                gpuIDs := make([]string, len(task.GPUIDs))
                for i, id := range task.GPUIDs </span><span class="cov0" title="0">{
                        gpuIDs[i] = strconv.Itoa(id)
                }</span>
                <span class="cov0" title="0">args = append([]string{fmt.Sprintf("--id=%s", strings.Join(gpuIDs, ","))}, args...)</span>
        }

        <span class="cov0" title="0">output, err := g.execNvidiaSMI(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to get memory info: %w", err)
        }</span>

        <span class="cov0" title="0">memoryInfo := g.parseMemoryInfo(output)

        result := map[string]interface{}{
                "action":      "memory-info",
                "memory_info": memoryInfo,
                "timestamp":   time.Now().UTC(),
        }

        return result, nil</span>
}

// getGPUProcesses gets processes running on GPUs.
func (g *GPUClient) getGPUProcesses(ctx context.Context, task *GPUTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        args := []string{
                "--query-compute-apps=gpu_uuid,pid,process_name,used_memory",
                "--format=csv,noheader,nounits",
        }

        output, err := g.execNvidiaSMI(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to get GPU processes: %w", err)
        }</span>

        <span class="cov0" title="0">processes := g.parseProcessInfo(output)

        result := map[string]interface{}{
                "action":    "processes",
                "processes": processes,
                "timestamp": time.Now().UTC(),
        }

        return result, nil</span>
}

// getGPUTopology gets GPU topology information.
func (g *GPUClient) getGPUTopology(ctx context.Context, task *GPUTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        args := []string{"topo", "-m"}

        output, err := g.execNvidiaSMI(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to get GPU topology: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":    "topology",
                "topology":  output,
                "timestamp": time.Now().UTC(),
        }

        return result, nil</span>
}

// resetGPUs resets GPU state.
func (g *GPUClient) resetGPUs(ctx context.Context, task *GPUTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        var args []string

        if len(task.GPUIDs) &gt; 0 </span><span class="cov0" title="0">{
                for _, id := range task.GPUIDs </span><span class="cov0" title="0">{
                        args = append(args, "--gpu-reset", "-i", strconv.Itoa(id))
                }</span>
        } else<span class="cov0" title="0"> {
                args = []string{"--gpu-reset"}
        }</span>

        <span class="cov0" title="0">output, err := g.execNvidiaSMI(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to reset GPUs: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":    "reset",
                "output":    output,
                "gpu_ids":   task.GPUIDs,
                "timestamp": time.Now().UTC(),
        }

        return result, nil</span>
}

// Helper methods

// checkNvidiaSMI checks if nvidia-smi is available.
func (g *GPUClient) checkNvidiaSMI(ctx context.Context) error <span class="cov0" title="0">{
        _, err := g.execNvidiaSMI(ctx, "--version")
        return err
}</span>

// execNvidiaSMI executes nvidia-smi command.
func (g *GPUClient) execNvidiaSMI(ctx context.Context, args ...string) (string, error) <span class="cov0" title="0">{
        return g.execCommand(ctx, g.cfg.NvidiaSMIPath, args...)
}</span>

// execCommand executes a command.
func (g *GPUClient) execCommand(ctx context.Context, command string, args ...string) (string, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, command, args...)

        var stdout, stderr strings.Builder
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return "", xerrors.Errorf("command failed: %w, stderr: %s", err, stderr.String())
        }</span>

        <span class="cov0" title="0">return stdout.String(), nil</span>
}

// parseGPUList parses nvidia-smi CSV output into GPUInfo structs.
func (g *GPUClient) parseGPUList(output string) ([]GPUInfo, error) <span class="cov0" title="0">{
        lines := strings.Split(strings.TrimSpace(output), "\n")
        var gpus []GPUInfo

        for _, line := range lines </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fields := strings.Split(line, ", ")
                if len(fields) &lt; 16 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">gpu := GPUInfo{}

                if id, err := strconv.Atoi(strings.TrimSpace(fields[0])); err == nil </span><span class="cov0" title="0">{
                        gpu.ID = id
                }</span>

                <span class="cov0" title="0">gpu.Name = strings.TrimSpace(fields[1])
                gpu.UUID = strings.TrimSpace(fields[2])
                gpu.PCIBusID = strings.TrimSpace(fields[3])
                gpu.DriverVersion = strings.TrimSpace(fields[4])
                gpu.CUDAVersion = strings.TrimSpace(fields[5])

                if memTotal, err := strconv.ParseInt(strings.TrimSpace(fields[6]), 10, 64); err == nil </span><span class="cov0" title="0">{
                        gpu.MemoryTotal = memTotal
                }</span>

                <span class="cov0" title="0">if memUsed, err := strconv.ParseInt(strings.TrimSpace(fields[7]), 10, 64); err == nil </span><span class="cov0" title="0">{
                        gpu.MemoryUsed = memUsed
                }</span>

                <span class="cov0" title="0">if memFree, err := strconv.ParseInt(strings.TrimSpace(fields[8]), 10, 64); err == nil </span><span class="cov0" title="0">{
                        gpu.MemoryFree = memFree
                }</span>

                <span class="cov0" title="0">if utilGPU, err := strconv.Atoi(strings.TrimSpace(fields[9])); err == nil </span><span class="cov0" title="0">{
                        gpu.UtilizationGPU = utilGPU
                }</span>

                <span class="cov0" title="0">if utilMem, err := strconv.Atoi(strings.TrimSpace(fields[10])); err == nil </span><span class="cov0" title="0">{
                        gpu.UtilizationMemory = utilMem
                }</span>

                <span class="cov0" title="0">if temp, err := strconv.Atoi(strings.TrimSpace(fields[11])); err == nil </span><span class="cov0" title="0">{
                        gpu.Temperature = temp
                }</span>

                <span class="cov0" title="0">if power, err := strconv.ParseFloat(strings.TrimSpace(fields[12]), 64); err == nil </span><span class="cov0" title="0">{
                        gpu.PowerDraw = power
                }</span>

                <span class="cov0" title="0">if powerLimit, err := strconv.ParseFloat(strings.TrimSpace(fields[13]), 64); err == nil </span><span class="cov0" title="0">{
                        gpu.PowerLimit = powerLimit
                }</span>

                <span class="cov0" title="0">if clockGfx, err := strconv.Atoi(strings.TrimSpace(fields[14])); err == nil </span><span class="cov0" title="0">{
                        gpu.ClockGraphics = clockGfx
                }</span>

                <span class="cov0" title="0">if clockMem, err := strconv.Atoi(strings.TrimSpace(fields[15])); err == nil </span><span class="cov0" title="0">{
                        gpu.ClockMemory = clockMem
                }</span>

                // Determine status based on utilization
                <span class="cov0" title="0">if gpu.UtilizationGPU &gt; 0 || len(gpu.Processes) &gt; 0 </span><span class="cov0" title="0">{
                        gpu.Status = "allocated"
                }</span> else<span class="cov0" title="0"> {
                        gpu.Status = "available"
                }</span>

                <span class="cov0" title="0">gpus = append(gpus, gpu)</span>
        }

        <span class="cov0" title="0">return gpus, nil</span>
}

// parseDetailedGPUInfo parses detailed GPU information.
func (g *GPUClient) parseDetailedGPUInfo(output string) ([]GPUInfo, error) <span class="cov0" title="0">{
        // Similar to parseGPUList but with additional fields
        return g.parseGPUList(output)
}</span>

// getProcessesForGPU gets processes for a specific GPU.
func (g *GPUClient) getProcessesForGPU(ctx context.Context, gpuID int) ([]GPUProcess, error) <span class="cov0" title="0">{
        args := []string{
                fmt.Sprintf("--id=%d", gpuID),
                "--query-compute-apps=pid,process_name,used_memory",
                "--format=csv,noheader,nounits",
        }

        output, err := g.execNvidiaSMI(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return g.parseProcessInfo(output), nil</span>
}

// parseProcessInfo parses process information from nvidia-smi output.
func (g *GPUClient) parseProcessInfo(output string) []GPUProcess <span class="cov0" title="0">{
        lines := strings.Split(strings.TrimSpace(output), "\n")
        var processes []GPUProcess

        for _, line := range lines </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fields := strings.Split(line, ", ")
                if len(fields) &lt; 3 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">process := GPUProcess{}

                if pid, err := strconv.Atoi(strings.TrimSpace(fields[0])); err == nil </span><span class="cov0" title="0">{
                        process.PID = pid
                }</span>

                <span class="cov0" title="0">process.ProcessName = strings.TrimSpace(fields[1])

                if memUsed, err := strconv.ParseInt(strings.TrimSpace(fields[2]), 10, 64); err == nil </span><span class="cov0" title="0">{
                        process.MemoryUsed = memUsed
                }</span>

                <span class="cov0" title="0">process.Type = "C" // Default to compute

                processes = append(processes, process)</span>
        }

        <span class="cov0" title="0">return processes</span>
}

// parseMemoryInfo parses memory information.
func (g *GPUClient) parseMemoryInfo(output string) []map[string]interface{} <span class="cov0" title="0">{
        lines := strings.Split(strings.TrimSpace(output), "\n")
        var memInfo []map[string]interface{}

        for _, line := range lines </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fields := strings.Split(line, ", ")
                if len(fields) &lt; 4 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">info := map[string]interface{}{
                        "gpu_id": strings.TrimSpace(fields[0]),
                }

                if memTotal, err := strconv.ParseInt(strings.TrimSpace(fields[1]), 10, 64); err == nil </span><span class="cov0" title="0">{
                        info["memory_total"] = memTotal
                }</span>

                <span class="cov0" title="0">if memUsed, err := strconv.ParseInt(strings.TrimSpace(fields[2]), 10, 64); err == nil </span><span class="cov0" title="0">{
                        info["memory_used"] = memUsed
                }</span>

                <span class="cov0" title="0">if memFree, err := strconv.ParseInt(strings.TrimSpace(fields[3]), 10, 64); err == nil </span><span class="cov0" title="0">{
                        info["memory_free"] = memFree
                }</span>

                <span class="cov0" title="0">memInfo = append(memInfo, info)</span>
        }

        <span class="cov0" title="0">return memInfo</span>
}

// collectMonitoringSample collects a monitoring sample.
func (g *GPUClient) collectMonitoringSample(ctx context.Context, task *GPUTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        gpuInfoTask := &amp;GPUTask{Action: "info", GPUIDs: task.GPUIDs}
        gpuInfoResult, err := g.getGPUInfo(ctx, gpuInfoTask)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sample := map[string]interface{}{
                "timestamp": time.Now().UTC(),
                "gpus":      gpuInfoResult["gpus"],
        }

        return sample, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package agentic provides a HuggingFace connector agent.
package agentic

import (
        "bytes"
        "context"
        "encoding/json"
        "io"
        "net/http"

        "golang.org/x/xerrors"
)

// HFConfig holds HuggingFace API config.
type HFConfig struct {
        APIKey   string
        Model    string
        Endpoint string // Optional, defaults to https://api-inference.huggingface.co/models/
}

// HFClient is an agent for HuggingFace LLM/embedding tasks.
type HFClient struct {
        cfg HFConfig
}

func NewHFClient(cfg HFConfig) *HFClient <span class="cov0" title="0">{
        return &amp;HFClient{cfg: cfg}
}</span>

func (h *HFClient) Name() string <span class="cov0" title="0">{ return "huggingface" }</span>

func (h *HFClient) Supports(taskType string) bool <span class="cov0" title="0">{
        return taskType == "llm" || taskType == "embedding"
}</span>

func (h *HFClient) Execute(ctx context.Context, task *Task) (*TaskResult, error) <span class="cov0" title="0">{
        endpoint := h.cfg.Endpoint
        if endpoint == "" </span><span class="cov0" title="0">{
                endpoint = "https://api-inference.huggingface.co/models/" + h.cfg.Model
        }</span>
        <span class="cov0" title="0">payload, err := json.Marshal(task.Payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", endpoint, bytes.NewReader(payload))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+h.cfg.APIKey)
        req.Header.Set("Content-Type", "application/json")
        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        body, _ := io.ReadAll(resp.Body)
        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return &amp;TaskResult{Error: xerrors.New(string(body))}, nil
        }</span>
        <span class="cov0" title="0">var out interface{}
        if err := json.Unmarshal(body, &amp;out); err != nil </span><span class="cov0" title="0">{
                return &amp;TaskResult{Output: string(body)}, nil
        }</span>
        <span class="cov0" title="0">return &amp;TaskResult{Output: out}, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package agentic provides an IO Intelligence connector agent.
package agentic

import (
        "bytes"
        "context"
        "encoding/json"
        "io"
        "net/http"

        "golang.org/x/xerrors"
)

// IOIConfig holds IO Intelligence API config.
type IOIConfig struct {
        APIKey   string
        Model    string
        Endpoint string // Optional, defaults to https://api.intelligence.io/v1/llm/
}

// IOIClient is an agent for IO Intelligence LLM/embedding tasks.
type IOIClient struct {
        cfg IOIConfig
}

func NewIOIClient(cfg IOIConfig) *IOIClient <span class="cov0" title="0">{
        return &amp;IOIClient{cfg: cfg}
}</span>

func (i *IOIClient) Name() string <span class="cov0" title="0">{ return "io_intelligence" }</span>

func (i *IOIClient) Supports(taskType string) bool <span class="cov0" title="0">{
        return taskType == "llm" || taskType == "embedding"
}</span>

func (i *IOIClient) Execute(ctx context.Context, task *Task) (*TaskResult, error) <span class="cov0" title="0">{
        endpoint := i.cfg.Endpoint
        if endpoint == "" </span><span class="cov0" title="0">{
                endpoint = "https://api.intelligence.io/v1/llm/" + i.cfg.Model
        }</span>
        <span class="cov0" title="0">payload, err := json.Marshal(task.Payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", endpoint, bytes.NewReader(payload))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+i.cfg.APIKey)
        req.Header.Set("Content-Type", "application/json")
        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        body, _ := io.ReadAll(resp.Body)
        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                return &amp;TaskResult{Error: xerrors.New(string(body))}, nil
        }</span>
        <span class="cov0" title="0">var out interface{}
        if err := json.Unmarshal(body, &amp;out); err != nil </span><span class="cov0" title="0">{
                return &amp;TaskResult{Output: string(body)}, nil
        }</span>
        <span class="cov0" title="0">return &amp;TaskResult{Output: out}, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package agentic provides Kubernetes connector for cluster orchestration.
package agentic

import (
        "context"
        "encoding/json"
        "fmt"
        "os/exec"
        "strings"

        "golang.org/x/xerrors"
)

// KubernetesConfig holds Kubernetes configuration.
type KubernetesConfig struct {
        Engine     string `json:"engine"`     // "kubectl", "microk8s", "k3s", "talosctl"
        Kubeconfig string `json:"kubeconfig"` // Path to kubeconfig file
        Context    string `json:"context"`    // Kubernetes context name
        Namespace  string `json:"namespace"`  // Default namespace
}

// KubernetesClient is an agent for Kubernetes cluster orchestration tasks.
type KubernetesClient struct {
        cfg KubernetesConfig
}

// KubernetesTask represents a Kubernetes orchestration task.
type KubernetesTask struct {
        Action    string                 `json:"action"`    // apply, delete, get, create, scale, logs, exec
        Resource  string                 `json:"resource"`  // pods, services, deployments, etc.
        Name      string                 `json:"name"`      // Resource name
        Namespace string                 `json:"namespace"` // Resource namespace
        Manifest  string                 `json:"manifest"`  // YAML/JSON manifest
        File      string                 `json:"file"`      // Manifest file path
        Labels    map[string]string      `json:"labels"`    // Label selectors
        Config    map[string]interface{} `json:"config"`    // Additional configuration
        Command   []string               `json:"command"`   // Command for exec
        Container string                 `json:"container"` // Container name for exec/logs
        Follow    bool                   `json:"follow"`    // Follow logs
        Replicas  int32                  `json:"replicas"`  // Number of replicas for scale
        GPUs      *K8sGPUConfig          `json:"gpus"`      // GPU configuration
}

// KubernetesResource represents a Kubernetes resource.
type KubernetesResource struct {
        Kind      string            `json:"kind"`
        Name      string            `json:"name"`
        Namespace string            `json:"namespace"`
        Labels    map[string]string `json:"labels"`
        Status    string            `json:"status"`
        Age       string            `json:"age"`
        Ready     string            `json:"ready,omitempty"`
        Restarts  string            `json:"restarts,omitempty"`
        IP        string            `json:"ip,omitempty"`
}

// K8sGPUConfig represents GPU configuration for Kubernetes resources.
type K8sGPUConfig struct {
        Enabled      bool              `json:"enabled"`       // Enable GPU support
        ResourceName string            `json:"resource_name"` // GPU resource name (nvidia.com/gpu, amd.com/gpu)
        Limit        int               `json:"limit"`         // Number of GPUs to request
        Request      int               `json:"request"`       // Number of GPUs to request (minimum)
        NodeSelector map[string]string `json:"node_selector"` // Node selector for GPU nodes
        Tolerations  []K8sToleration   `json:"tolerations"`   // Tolerations for GPU nodes
        RuntimeClass string            `json:"runtime_class"` // Runtime class for GPU workloads
        DevicePlugin string            `json:"device_plugin"` // Device plugin type (nvidia, amd)
}

// K8sToleration represents a Kubernetes toleration.
type K8sToleration struct {
        Key      string `json:"key"`
        Operator string `json:"operator"`
        Value    string `json:"value"`
        Effect   string `json:"effect"`
}

// NewKubernetesClient creates a new Kubernetes client.
func NewKubernetesClient(cfg KubernetesConfig) *KubernetesClient <span class="cov0" title="0">{
        if cfg.Engine == "" </span><span class="cov0" title="0">{
                cfg.Engine = "kubectl" // Default to kubectl
        }</span>

        <span class="cov0" title="0">return &amp;KubernetesClient{cfg: cfg}</span>
}

func (k *KubernetesClient) Name() string <span class="cov0" title="0">{ return "kubernetes" }</span>

func (k *KubernetesClient) Supports(taskType string) bool <span class="cov0" title="0">{
        return taskType == "kubernetes" || taskType == "k8s" || taskType == "cluster"
}</span>

func (k *KubernetesClient) Execute(ctx context.Context, task *Task) (*TaskResult, error) <span class="cov0" title="0">{
        // Parse task payload
        var k8sTask KubernetesTask
        if err := mapToStruct(task.Payload, &amp;k8sTask); err != nil </span><span class="cov0" title="0">{
                return &amp;TaskResult{Error: xerrors.Errorf("invalid task payload: %w", err)}, nil
        }</span>

        // Execute based on action
        <span class="cov0" title="0">switch k8sTask.Action </span>{
        case "apply":<span class="cov0" title="0">
                result, err := k.applyManifest(ctx, &amp;k8sTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "delete":<span class="cov0" title="0">
                result, err := k.deleteResource(ctx, &amp;k8sTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "get", "list":<span class="cov0" title="0">
                result, err := k.getResources(ctx, &amp;k8sTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "create":<span class="cov0" title="0">
                result, err := k.createResource(ctx, &amp;k8sTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "scale":<span class="cov0" title="0">
                result, err := k.scaleResource(ctx, &amp;k8sTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "logs":<span class="cov0" title="0">
                result, err := k.getLogs(ctx, &amp;k8sTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "exec":<span class="cov0" title="0">
                result, err := k.execCommand(ctx, &amp;k8sTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "describe":<span class="cov0" title="0">
                result, err := k.describeResource(ctx, &amp;k8sTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "port-forward":<span class="cov0" title="0">
                result, err := k.portForward(ctx, &amp;k8sTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "cluster-info":<span class="cov0" title="0">
                result, err := k.getClusterInfo(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        default:<span class="cov0" title="0">
                return &amp;TaskResult{Error: xerrors.Errorf("unsupported action: %s", k8sTask.Action)}, nil</span>
        }
}

// applyManifest applies a Kubernetes manifest.
func (k *KubernetesClient) applyManifest(ctx context.Context, task *KubernetesTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        args := []string{"apply"}

        // Add namespace if specified
        if task.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", task.Namespace)
        }</span> else<span class="cov0" title="0"> if k.cfg.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", k.cfg.Namespace)
        }</span>

        // Apply from manifest string or file
        <span class="cov0" title="0">if task.Manifest != "" </span><span class="cov0" title="0">{
                args = append(args, "-f", "-")
        }</span> else<span class="cov0" title="0"> if task.File != "" </span><span class="cov0" title="0">{
                args = append(args, "-f", task.File)
        }</span> else<span class="cov0" title="0"> {
                return nil, xerrors.New("either manifest or file must be specified")
        }</span>

        <span class="cov0" title="0">var input string
        if task.Manifest != "" </span><span class="cov0" title="0">{
                input = task.Manifest
        }</span>

        <span class="cov0" title="0">output, err := k.runCommand(ctx, input, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to apply manifest: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action": "apply",
                "output": output,
        }

        return result, nil</span>
}

// deleteResource deletes a Kubernetes resource.
func (k *KubernetesClient) deleteResource(ctx context.Context, task *KubernetesTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        args := []string{"delete"}

        if task.Resource == "" </span><span class="cov0" title="0">{
                return nil, xerrors.New("resource type is required")
        }</span>

        <span class="cov0" title="0">args = append(args, task.Resource)

        if task.Name != "" </span><span class="cov0" title="0">{
                args = append(args, task.Name)
        }</span>

        // Add namespace if specified
        <span class="cov0" title="0">if task.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", task.Namespace)
        }</span> else<span class="cov0" title="0"> if k.cfg.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", k.cfg.Namespace)
        }</span>

        // Add label selectors
        <span class="cov0" title="0">if len(task.Labels) &gt; 0 </span><span class="cov0" title="0">{
                var labelSelectors []string
                for key, value := range task.Labels </span><span class="cov0" title="0">{
                        labelSelectors = append(labelSelectors, fmt.Sprintf("%s=%s", key, value))
                }</span>
                <span class="cov0" title="0">args = append(args, "-l", strings.Join(labelSelectors, ","))</span>
        }

        // Delete from file if specified
        <span class="cov0" title="0">if task.File != "" </span><span class="cov0" title="0">{
                args = append(args, "-f", task.File)
        }</span>

        <span class="cov0" title="0">output, err := k.runCommand(ctx, "", args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to delete resource: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":   "delete",
                "resource": task.Resource,
                "name":     task.Name,
                "output":   output,
        }

        return result, nil</span>
}

// getResources gets Kubernetes resources.
func (k *KubernetesClient) getResources(ctx context.Context, task *KubernetesTask) ([]KubernetesResource, error) <span class="cov0" title="0">{
        args := []string{"get"}

        if task.Resource == "" </span><span class="cov0" title="0">{
                task.Resource = "pods" // Default to pods
        }</span>

        <span class="cov0" title="0">args = append(args, task.Resource)

        if task.Name != "" </span><span class="cov0" title="0">{
                args = append(args, task.Name)
        }</span>

        // Add namespace if specified
        <span class="cov0" title="0">if task.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", task.Namespace)
        }</span> else<span class="cov0" title="0"> if k.cfg.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", k.cfg.Namespace)
        }</span>

        // Add label selectors
        <span class="cov0" title="0">if len(task.Labels) &gt; 0 </span><span class="cov0" title="0">{
                var labelSelectors []string
                for key, value := range task.Labels </span><span class="cov0" title="0">{
                        labelSelectors = append(labelSelectors, fmt.Sprintf("%s=%s", key, value))
                }</span>
                <span class="cov0" title="0">args = append(args, "-l", strings.Join(labelSelectors, ","))</span>
        }

        // Output as JSON for easier parsing
        <span class="cov0" title="0">args = append(args, "-o", "json")

        output, err := k.runCommand(ctx, "", args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to get resources: %w", err)
        }</span>

        // Parse JSON output
        <span class="cov0" title="0">var response struct {
                Items []map[string]interface{} `json:"items"`
        }

        if err := json.Unmarshal([]byte(output), &amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to parse kubectl output: %w", err)
        }</span>

        <span class="cov0" title="0">var resources []KubernetesResource
        for _, item := range response.Items </span><span class="cov0" title="0">{
                resource := KubernetesResource{
                        Kind:      getStringField(item, "kind"),
                        Name:      getNestedStringField(item, "metadata", "name"),
                        Namespace: getNestedStringField(item, "metadata", "namespace"),
                }

                // Extract labels
                if labels, ok := getNestedField(item, "metadata", "labels").(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        resource.Labels = make(map[string]string)
                        for k, v := range labels </span><span class="cov0" title="0">{
                                if str, ok := v.(string); ok </span><span class="cov0" title="0">{
                                        resource.Labels[k] = str
                                }</span>
                        }
                }

                // Extract status based on resource type
                <span class="cov0" title="0">if status := getNestedStringField(item, "status", "phase"); status != "" </span><span class="cov0" title="0">{
                        resource.Status = status
                }</span> else<span class="cov0" title="0"> if conditions := getNestedField(item, "status", "conditions"); conditions != nil </span><span class="cov0" title="0">{
                        // For deployments and other resources with conditions
                        resource.Status = "Unknown"
                }</span>

                <span class="cov0" title="0">resources = append(resources, resource)</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

// createResource creates a Kubernetes resource.
func (k *KubernetesClient) createResource(ctx context.Context, task *KubernetesTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        args := []string{"create"}

        // Add namespace if specified
        if task.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", task.Namespace)
        }</span> else<span class="cov0" title="0"> if k.cfg.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", k.cfg.Namespace)
        }</span>

        // Create from manifest string or file
        <span class="cov0" title="0">if task.Manifest != "" </span><span class="cov0" title="0">{
                args = append(args, "-f", "-")
        }</span> else<span class="cov0" title="0"> if task.File != "" </span><span class="cov0" title="0">{
                args = append(args, "-f", task.File)
        }</span> else<span class="cov0" title="0"> {
                return nil, xerrors.New("either manifest or file must be specified")
        }</span>

        <span class="cov0" title="0">var input string
        if task.Manifest != "" </span><span class="cov0" title="0">{
                input = task.Manifest
        }</span>

        <span class="cov0" title="0">output, err := k.runCommand(ctx, input, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to create resource: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action": "create",
                "output": output,
        }

        return result, nil</span>
}

// scaleResource scales a Kubernetes resource.
func (k *KubernetesClient) scaleResource(ctx context.Context, task *KubernetesTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if task.Resource == "" || task.Name == "" </span><span class="cov0" title="0">{
                return nil, xerrors.New("resource type and name are required")
        }</span>

        <span class="cov0" title="0">args := []string{"scale", task.Resource, task.Name}

        // Add namespace if specified
        if task.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", task.Namespace)
        }</span> else<span class="cov0" title="0"> if k.cfg.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", k.cfg.Namespace)
        }</span>

        // Add replicas
        <span class="cov0" title="0">args = append(args, fmt.Sprintf("--replicas=%d", task.Replicas))

        output, err := k.runCommand(ctx, "", args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to scale resource: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":   "scale",
                "resource": task.Resource,
                "name":     task.Name,
                "replicas": task.Replicas,
                "output":   output,
        }

        return result, nil</span>
}

// getLogs gets logs from a pod.
func (k *KubernetesClient) getLogs(ctx context.Context, task *KubernetesTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if task.Name == "" </span><span class="cov0" title="0">{
                return nil, xerrors.New("pod name is required")
        }</span>

        <span class="cov0" title="0">args := []string{"logs", task.Name}

        // Add namespace if specified
        if task.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", task.Namespace)
        }</span> else<span class="cov0" title="0"> if k.cfg.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", k.cfg.Namespace)
        }</span>

        // Add container if specified
        <span class="cov0" title="0">if task.Container != "" </span><span class="cov0" title="0">{
                args = append(args, "-c", task.Container)
        }</span>

        // Follow logs if requested
        <span class="cov0" title="0">if task.Follow </span><span class="cov0" title="0">{
                args = append(args, "-f")
        }</span>

        // Add additional options from config
        <span class="cov0" title="0">if task.Config != nil </span><span class="cov0" title="0">{
                if tail, ok := task.Config["tail"].(string); ok &amp;&amp; tail != "" </span><span class="cov0" title="0">{
                        args = append(args, "--tail", tail)
                }</span>
                <span class="cov0" title="0">if since, ok := task.Config["since"].(string); ok &amp;&amp; since != "" </span><span class="cov0" title="0">{
                        args = append(args, "--since", since)
                }</span>
        }

        <span class="cov0" title="0">output, err := k.runCommand(ctx, "", args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to get logs: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":    "logs",
                "pod":       task.Name,
                "container": task.Container,
                "logs":      output,
        }

        return result, nil</span>
}

// execCommand executes a command in a pod.
func (k *KubernetesClient) execCommand(ctx context.Context, task *KubernetesTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if task.Name == "" </span><span class="cov0" title="0">{
                return nil, xerrors.New("pod name is required")
        }</span>

        <span class="cov0" title="0">if len(task.Command) == 0 </span><span class="cov0" title="0">{
                return nil, xerrors.New("command is required")
        }</span>

        <span class="cov0" title="0">args := []string{"exec", task.Name}

        // Add namespace if specified
        if task.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", task.Namespace)
        }</span> else<span class="cov0" title="0"> if k.cfg.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", k.cfg.Namespace)
        }</span>

        // Add container if specified
        <span class="cov0" title="0">if task.Container != "" </span><span class="cov0" title="0">{
                args = append(args, "-c", task.Container)
        }</span>

        // Add interactive and tty flags if requested
        <span class="cov0" title="0">if task.Config != nil </span><span class="cov0" title="0">{
                if interactive, ok := task.Config["interactive"].(bool); ok &amp;&amp; interactive </span><span class="cov0" title="0">{
                        args = append(args, "-i")
                }</span>
                <span class="cov0" title="0">if tty, ok := task.Config["tty"].(bool); ok &amp;&amp; tty </span><span class="cov0" title="0">{
                        args = append(args, "-t")
                }</span>
        }

        // Add -- separator and command
        <span class="cov0" title="0">args = append(args, "--")
        args = append(args, task.Command...)

        output, err := k.runCommand(ctx, "", args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to exec command: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":    "exec",
                "pod":       task.Name,
                "container": task.Container,
                "command":   task.Command,
                "output":    output,
        }

        return result, nil</span>
}

// describeResource describes a Kubernetes resource.
func (k *KubernetesClient) describeResource(ctx context.Context, task *KubernetesTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if task.Resource == "" || task.Name == "" </span><span class="cov0" title="0">{
                return nil, xerrors.New("resource type and name are required")
        }</span>

        <span class="cov0" title="0">args := []string{"describe", task.Resource, task.Name}

        // Add namespace if specified
        if task.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", task.Namespace)
        }</span> else<span class="cov0" title="0"> if k.cfg.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", k.cfg.Namespace)
        }</span>

        <span class="cov0" title="0">output, err := k.runCommand(ctx, "", args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to describe resource: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":      "describe",
                "resource":    task.Resource,
                "name":        task.Name,
                "description": output,
        }

        return result, nil</span>
}

// portForward forwards ports from a pod.
func (k *KubernetesClient) portForward(ctx context.Context, task *KubernetesTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if task.Name == "" </span><span class="cov0" title="0">{
                return nil, xerrors.New("pod name is required")
        }</span>

        <span class="cov0" title="0">if task.Config == nil || task.Config["ports"] == nil </span><span class="cov0" title="0">{
                return nil, xerrors.New("ports configuration is required")
        }</span>

        <span class="cov0" title="0">ports, ok := task.Config["ports"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, xerrors.New("ports must be a string (e.g., '8080:80')")
        }</span>

        <span class="cov0" title="0">args := []string{"port-forward", task.Name, ports}

        // Add namespace if specified
        if task.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", task.Namespace)
        }</span> else<span class="cov0" title="0"> if k.cfg.Namespace != "" </span><span class="cov0" title="0">{
                args = append(args, "-n", k.cfg.Namespace)
        }</span>

        <span class="cov0" title="0">output, err := k.runCommand(ctx, "", args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to port-forward: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action": "port-forward",
                "pod":    task.Name,
                "ports":  ports,
                "output": output,
        }

        return result, nil</span>
}

// getClusterInfo gets cluster information.
func (k *KubernetesClient) getClusterInfo(ctx context.Context) (map[string]interface{}, error) <span class="cov0" title="0">{
        args := []string{"cluster-info"}

        output, err := k.runCommand(ctx, "", args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to get cluster info: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":       "cluster-info",
                "cluster_info": output,
        }

        return result, nil</span>
}

// runCommand runs a kubectl/k8s command.
func (k *KubernetesClient) runCommand(ctx context.Context, input string, args ...string) (string, error) <span class="cov0" title="0">{
        var cmdName string
        var cmdArgs []string

        switch k.cfg.Engine </span>{
        case "microk8s":<span class="cov0" title="0">
                cmdName = "microk8s"
                cmdArgs = append([]string{"kubectl"}, args...)</span>
        case "k3s":<span class="cov0" title="0">
                cmdName = "k3s"
                cmdArgs = append([]string{"kubectl"}, args...)</span>
        case "talosctl":<span class="cov0" title="0">
                // For Talos, we need to use talosctl with different commands
                cmdName = "talosctl"
                cmdArgs = k.convertToTalosCommand(args)</span>
        default:<span class="cov0" title="0">
                cmdName = "kubectl"
                cmdArgs = args</span>
        }

        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, cmdName, cmdArgs...)

        // Set kubeconfig if specified
        if k.cfg.Kubeconfig != "" &amp;&amp; k.cfg.Engine != "talosctl" </span><span class="cov0" title="0">{
                cmd.Env = append(cmd.Env, "KUBECONFIG="+k.cfg.Kubeconfig)
        }</span>

        // Set kubectl context if specified
        <span class="cov0" title="0">if k.cfg.Context != "" &amp;&amp; k.cfg.Engine != "talosctl" </span><span class="cov0" title="0">{
                cmd.Args = append(cmd.Args, "--context", k.cfg.Context)
        }</span>

        <span class="cov0" title="0">var stdout, stderr strings.Builder
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        // Set input if provided
        if input != "" </span><span class="cov0" title="0">{
                cmd.Stdin = strings.NewReader(input)
        }</span>

        <span class="cov0" title="0">err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return "", xerrors.Errorf("command failed: %w, stderr: %s", err, stderr.String())
        }</span>

        <span class="cov0" title="0">return stdout.String(), nil</span>
}

// convertToTalosCommand converts kubectl commands to talosctl equivalents.
func (k *KubernetesClient) convertToTalosCommand(args []string) []string <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return args
        }</span>

        // For now, we'll pass through kubectl commands to talosctl's kubectl
        // In a full implementation, you'd convert to native talosctl commands
        <span class="cov0" title="0">return append([]string{"kubectl"}, args...)</span>
}

// getNestedField safely gets a nested field from a map.
func getNestedField(m map[string]interface{}, keys ...string) interface{} <span class="cov0" title="0">{
        current := m
        for i, key := range keys </span><span class="cov0" title="0">{
                if val, ok := current[key]; ok </span><span class="cov0" title="0">{
                        if i == len(keys)-1 </span><span class="cov0" title="0">{
                                return val
                        }</span>
                        <span class="cov0" title="0">if next, ok := val.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                current = next
                        }</span> else<span class="cov0" title="0"> {
                                return nil
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// getNestedStringField safely gets a nested string field from a map.
func getNestedStringField(m map[string]interface{}, keys ...string) string <span class="cov0" title="0">{
        if val := getNestedField(m, keys...); val != nil </span><span class="cov0" title="0">{
                if str, ok := val.(string); ok </span><span class="cov0" title="0">{
                        return str
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package agentic provides a Nix/NixOS connector for reproducible infrastructure management.
package agentic

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        "golang.org/x/xerrors"
)

// NixClient is an agent for Nix/NixOS reproducible infrastructure tasks.
type NixClient struct {
        cfg NixConfig
}

// NixTask represents a Nix/NixOS orchestration task.
type NixTask struct {
        Action      string                 `json:"action"`      // build, shell, install, develop, rebuild, deploy, flake
        Expression  string                 `json:"expression"`  // Nix expression or flake reference
        Derivation  string                 `json:"derivation"`  // .drv file path
        FlakeRef    string                 `json:"flake_ref"`   // Flake reference (e.g., github:owner/repo)
        Attribute   string                 `json:"attribute"`   // Attribute to build (e.g., packages.x86_64-linux.hello)
        System      string                 `json:"system"`      // Target system (x86_64-linux, aarch64-linux, etc.)
        Profile     string                 `json:"profile"`     // Nix profile path
        Generation  int                    `json:"generation"`  // Specific generation number
        Config      map[string]interface{} `json:"config"`      // Additional configuration
        Environment map[string]string      `json:"environment"` // Environment variables
        Args        []string               `json:"args"`        // Additional command arguments
        WorkDir     string                 `json:"workdir"`     // Working directory
        Remote      *NixRemoteConfig       `json:"remote"`      // Remote execution config
        Nixpkgs     string                 `json:"nixpkgs"`     // Nixpkgs channel or path
}

// NixRemoteConfig represents remote execution configuration.
type NixRemoteConfig struct {
        Host       string `json:"host"`
        User       string `json:"user"`
        SSHKey     string `json:"ssh_key"`
        SystemType string `json:"system_type"`
}

// NixBuildResult represents the result of a Nix build.
type NixBuildResult struct {
        StorePath  string            `json:"store_path"`
        DrvPath    string            `json:"drv_path"`
        Outputs    map[string]string `json:"outputs"`
        BuildTime  time.Duration     `json:"build_time"`
        CacheHit   bool              `json:"cache_hit"`
        SystemType string            `json:"system_type"`
}

// NixSystemInfo represents NixOS system information.
type NixSystemInfo struct {
        Generation    int               `json:"generation"`
        ConfigPath    string            `json:"config_path"`
        KernelVersion string            `json:"kernel_version"`
        SystemVersion string            `json:"system_version"`
        Packages      map[string]string `json:"packages"`
        Services      []string          `json:"services"`
}

// FlakeInfo represents Nix flake information.
type FlakeInfo struct {
        Description string                 `json:"description"`
        URL         string                 `json:"url"`
        Locked      bool                   `json:"locked"`
        Outputs     map[string]interface{} `json:"outputs"`
        Inputs      map[string]interface{} `json:"inputs"`
}

// NewNixClient creates a new Nix/NixOS client.
func NewNixClient(cfg NixConfig) *NixClient <span class="cov0" title="0">{
        // Set sensible defaults
        if !cfg.FlakesEnabled </span><span class="cov0" title="0">{
                // Check if flakes are already enabled
                cfg.FlakesEnabled = isFlakesEnabled()
        }</span>

        <span class="cov0" title="0">if len(cfg.Substitutes) == 0 </span><span class="cov0" title="0">{
                cfg.Substitutes = []string{"https://cache.nixos.org/"}
        }</span>

        <span class="cov0" title="0">return &amp;NixClient{cfg: cfg}</span>
}

func (n *NixClient) Name() string <span class="cov0" title="0">{ return "nix" }</span>

func (n *NixClient) Supports(taskType string) bool <span class="cov0" title="0">{
        return taskType == "nix" || taskType == "nixos" || taskType == "flake" || taskType == "reproducible"
}</span>

func (n *NixClient) Execute(ctx context.Context, task *Task) (*TaskResult, error) <span class="cov0" title="0">{
        // Parse task payload
        var nixTask NixTask
        if err := mapToStruct(task.Payload, &amp;nixTask); err != nil </span><span class="cov0" title="0">{
                return &amp;TaskResult{Error: xerrors.Errorf("invalid task payload: %w", err)}, nil
        }</span>

        // Execute based on action
        <span class="cov0" title="0">switch nixTask.Action </span>{
        case "build":<span class="cov0" title="0">
                result, err := n.buildExpression(ctx, &amp;nixTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "shell":<span class="cov0" title="0">
                result, err := n.nixShell(ctx, &amp;nixTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "install":<span class="cov0" title="0">
                result, err := n.installPackage(ctx, &amp;nixTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "develop":<span class="cov0" title="0">
                result, err := n.nixDevelop(ctx, &amp;nixTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "rebuild":<span class="cov0" title="0">
                result, err := n.nixosRebuild(ctx, &amp;nixTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "deploy":<span class="cov0" title="0">
                result, err := n.deployToRemote(ctx, &amp;nixTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "flake":<span class="cov0" title="0">
                result, err := n.flakeOperation(ctx, &amp;nixTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "gc":<span class="cov0" title="0">
                result, err := n.garbageCollect(ctx, &amp;nixTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "search":<span class="cov0" title="0">
                result, err := n.searchPackages(ctx, &amp;nixTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "info":<span class="cov0" title="0">
                result, err := n.systemInfo(ctx, &amp;nixTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "store":<span class="cov0" title="0">
                result, err := n.storeOperation(ctx, &amp;nixTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        default:<span class="cov0" title="0">
                return &amp;TaskResult{Error: xerrors.Errorf("unsupported action: %s", nixTask.Action)}, nil</span>
        }
}

// buildExpression builds a Nix expression or flake.
func (n *NixClient) buildExpression(ctx context.Context, task *NixTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        startTime := time.Now()

        var args []string
        if task.FlakeRef != "" </span><span class="cov0" title="0">{
                // Build flake reference
                args = []string{"build"}
                if n.cfg.FlakesEnabled </span><span class="cov0" title="0">{
                        args = append(args, "--experimental-features", "nix-command flakes")
                }</span>
                <span class="cov0" title="0">args = append(args, task.FlakeRef)
                if task.Attribute != "" </span><span class="cov0" title="0">{
                        args[len(args)-1] = fmt.Sprintf("%s#%s", task.FlakeRef, task.Attribute)
                }</span>
        } else<span class="cov0" title="0"> if task.Expression != "" </span><span class="cov0" title="0">{
                // Build expression
                args = []string{"build", "-E", task.Expression}
        }</span> else<span class="cov0" title="0"> {
                return nil, xerrors.New("either expression or flake_ref must be specified")
        }</span>

        // Add system specification
        <span class="cov0" title="0">if task.System != "" </span><span class="cov0" title="0">{
                args = append(args, "--system", task.System)
        }</span>

        // Add extra arguments
        <span class="cov0" title="0">args = append(args, task.Args...)

        output, err := n.execNixCommand(ctx, task, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to build expression: %w", err)
        }</span>

        <span class="cov0" title="0">buildTime := time.Since(startTime)

        // Parse output paths
        lines := strings.Split(strings.TrimSpace(output), "\n")
        var storePaths []string
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.HasPrefix(line, "/nix/store/") </span><span class="cov0" title="0">{
                        storePaths = append(storePaths, line)
                }</span>
        }

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":      "build",
                "store_paths": storePaths,
                "build_time":  buildTime.String(),
                "system":      task.System,
                "output":      output,
        }

        return result, nil</span>
}

// nixShell creates a Nix shell environment.
func (n *NixClient) nixShell(ctx context.Context, task *NixTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        var args []string

        if task.FlakeRef != "" </span><span class="cov0" title="0">{
                // Use flake for shell
                args = []string{"shell"}
                if n.cfg.FlakesEnabled </span><span class="cov0" title="0">{
                        args = append(args, "--experimental-features", "nix-command flakes")
                }</span>
                <span class="cov0" title="0">args = append(args, task.FlakeRef)
                if task.Attribute != "" </span><span class="cov0" title="0">{
                        args[len(args)-1] = fmt.Sprintf("%s#%s", task.FlakeRef, task.Attribute)
                }</span>
        } else<span class="cov0" title="0"> if task.Expression != "" </span><span class="cov0" title="0">{
                // Use expression for shell
                args = []string{"shell", "-E", task.Expression}
        }</span> else<span class="cov0" title="0"> {
                return nil, xerrors.New("either expression or flake_ref must be specified")
        }</span>

        // Add command to run in shell
        <span class="cov0" title="0">if task.Config != nil </span><span class="cov0" title="0">{
                if command, ok := task.Config["command"].(string); ok &amp;&amp; command != "" </span><span class="cov0" title="0">{
                        args = append(args, "--command", command)
                }</span>
        }

        // Add extra arguments
        <span class="cov0" title="0">args = append(args, task.Args...)

        output, err := n.execNixCommand(ctx, task, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to create nix shell: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action": "shell",
                "output": output,
        }

        return result, nil</span>
}

// installPackage installs a package using nix-env or nix profile.
func (n *NixClient) installPackage(ctx context.Context, task *NixTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        var args []string

        if task.FlakeRef != "" &amp;&amp; n.cfg.FlakesEnabled </span><span class="cov0" title="0">{
                // Use nix profile for flakes
                args = []string{"profile", "install"}
                args = append(args, "--experimental-features", "nix-command flakes")
                args = append(args, task.FlakeRef)
                if task.Attribute != "" </span><span class="cov0" title="0">{
                        args[len(args)-1] = fmt.Sprintf("%s#%s", task.FlakeRef, task.Attribute)
                }</span>
        } else<span class="cov0" title="0"> {
                // Use nix-env for traditional packages
                args = []string{"env", "-i"}
                if task.Expression != "" </span><span class="cov0" title="0">{
                        args = append(args, "-E", task.Expression)
                }</span> else<span class="cov0" title="0"> if task.Attribute != "" </span><span class="cov0" title="0">{
                        args = append(args, "-A", task.Attribute)
                }</span> else<span class="cov0" title="0"> {
                        return nil, xerrors.New("package name, expression, or flake reference required")
                }</span>
        }

        // Add profile if specified
        <span class="cov0" title="0">if task.Profile != "" </span><span class="cov0" title="0">{
                args = append(args, "--profile", task.Profile)
        }</span>

        // Add extra arguments
        <span class="cov0" title="0">args = append(args, task.Args...)

        output, err := n.execNixCommand(ctx, task, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to install package: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":  "install",
                "package": task.Attribute,
                "output":  output,
        }

        return result, nil</span>
}

// nixDevelop creates a development environment.
func (n *NixClient) nixDevelop(ctx context.Context, task *NixTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        args := []string{"develop"}

        if n.cfg.FlakesEnabled </span><span class="cov0" title="0">{
                args = append(args, "--experimental-features", "nix-command flakes")
        }</span>

        <span class="cov0" title="0">if task.FlakeRef != "" </span><span class="cov0" title="0">{
                args = append(args, task.FlakeRef)
                if task.Attribute != "" </span><span class="cov0" title="0">{
                        args[len(args)-1] = fmt.Sprintf("%s#%s", task.FlakeRef, task.Attribute)
                }</span>
        }

        // Add command to run
        <span class="cov0" title="0">if task.Config != nil </span><span class="cov0" title="0">{
                if command, ok := task.Config["command"].(string); ok &amp;&amp; command != "" </span><span class="cov0" title="0">{
                        args = append(args, "--command", command)
                }</span>
        }

        // Add extra arguments
        <span class="cov0" title="0">args = append(args, task.Args...)

        output, err := n.execNixCommand(ctx, task, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to create development environment: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action": "develop",
                "output": output,
        }

        return result, nil</span>
}

// nixosRebuild rebuilds NixOS system configuration.
func (n *NixClient) nixosRebuild(ctx context.Context, task *NixTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Default to 'switch' if no specific action
        action := "switch"
        if task.Config != nil </span><span class="cov0" title="0">{
                if rebuildAction, ok := task.Config["rebuild_action"].(string); ok </span><span class="cov0" title="0">{
                        action = rebuildAction
                }</span>
        }

        <span class="cov0" title="0">args := []string{"rebuild", action}

        // Add flake reference if specified
        if task.FlakeRef != "" </span><span class="cov0" title="0">{
                args = append(args, "--flake", task.FlakeRef)
                if task.Attribute != "" </span><span class="cov0" title="0">{
                        args[len(args)-1] = fmt.Sprintf("%s#%s", task.FlakeRef, task.Attribute)
                }</span>
        }

        // Add target host for remote rebuilds
        <span class="cov0" title="0">if task.Remote != nil </span><span class="cov0" title="0">{
                args = append(args, "--target-host", fmt.Sprintf("%s@%s", task.Remote.User, task.Remote.Host))
                if task.Remote.SSHKey != "" </span><span class="cov0" title="0">{
                        // Set SSH key via environment or config
                        task.Environment = mergeEnvMaps(task.Environment, map[string]string{
                                "NIX_SSHOPTS": fmt.Sprintf("-i %s", task.Remote.SSHKey),
                        })
                }</span>
        }

        // Add extra arguments
        <span class="cov0" title="0">args = append(args, task.Args...)

        output, err := n.execNixOSCommand(ctx, task, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to rebuild NixOS: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":         "rebuild",
                "rebuild_action": action,
                "output":         output,
        }

        return result, nil</span>
}

// deployToRemote deploys configuration to remote NixOS machine.
func (n *NixClient) deployToRemote(ctx context.Context, task *NixTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if task.Remote == nil </span><span class="cov0" title="0">{
                return nil, xerrors.New("remote configuration is required for deployment")
        }</span>

        // Use nixos-rebuild with target-host
        <span class="cov0" title="0">args := []string{"rebuild", "switch"}
        args = append(args, "--target-host", fmt.Sprintf("%s@%s", task.Remote.User, task.Remote.Host))

        if task.FlakeRef != "" </span><span class="cov0" title="0">{
                args = append(args, "--flake", task.FlakeRef)
                if task.Attribute != "" </span><span class="cov0" title="0">{
                        args[len(args)-1] = fmt.Sprintf("%s#%s", task.FlakeRef, task.Attribute)
                }</span>
        }

        // Set SSH options
        <span class="cov0" title="0">if task.Remote.SSHKey != "" </span><span class="cov0" title="0">{
                task.Environment = mergeEnvMaps(task.Environment, map[string]string{
                        "NIX_SSHOPTS": fmt.Sprintf("-i %s -o StrictHostKeyChecking=no", task.Remote.SSHKey),
                })
        }</span>

        // Add extra arguments
        <span class="cov0" title="0">args = append(args, task.Args...)

        output, err := n.execNixOSCommand(ctx, task, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to deploy to remote: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action": "deploy",
                "target": fmt.Sprintf("%s@%s", task.Remote.User, task.Remote.Host),
                "output": output,
        }

        return result, nil</span>
}

// flakeOperation performs flake-specific operations.
func (n *NixClient) flakeOperation(ctx context.Context, task *NixTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if !n.cfg.FlakesEnabled </span><span class="cov0" title="0">{
                return nil, xerrors.New("flakes are not enabled")
        }</span>

        <span class="cov0" title="0">flakeAction := "show"
        if task.Config != nil </span><span class="cov0" title="0">{
                if action, ok := task.Config["flake_action"].(string); ok </span><span class="cov0" title="0">{
                        flakeAction = action
                }</span>
        }

        <span class="cov0" title="0">args := []string{"flake", flakeAction}
        args = append(args, "--experimental-features", "nix-command flakes")

        if task.FlakeRef != "" </span><span class="cov0" title="0">{
                args = append(args, task.FlakeRef)
        }</span>

        // Add extra arguments
        <span class="cov0" title="0">args = append(args, task.Args...)

        output, err := n.execNixCommand(ctx, task, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to execute flake operation: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":       "flake",
                "flake_action": flakeAction,
                "flake_ref":    task.FlakeRef,
                "output":       output,
        }

        // Try to parse as JSON for certain operations
        if flakeAction == "show" || flakeAction == "metadata" </span><span class="cov0" title="0">{
                var flakeInfo map[string]interface{}
                if err := json.Unmarshal([]byte(output), &amp;flakeInfo); err == nil </span><span class="cov0" title="0">{
                        result["parsed_output"] = flakeInfo
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// garbageCollect performs Nix store garbage collection.
func (n *NixClient) garbageCollect(ctx context.Context, task *NixTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        args := []string{"store", "gc"}

        // Add deletion options
        if task.Config != nil </span><span class="cov0" title="0">{
                if maxAge, ok := task.Config["max_age"].(string); ok &amp;&amp; maxAge != "" </span><span class="cov0" title="0">{
                        args = append(args, "--max-age", maxAge)
                }</span>
                <span class="cov0" title="0">if dryRun, ok := task.Config["dry_run"].(bool); ok &amp;&amp; dryRun </span><span class="cov0" title="0">{
                        args = append(args, "--dry-run")
                }</span>
        }

        // Add extra arguments
        <span class="cov0" title="0">args = append(args, task.Args...)

        output, err := n.execNixCommand(ctx, task, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to garbage collect: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action": "gc",
                "output": output,
        }

        return result, nil</span>
}

// searchPackages searches for packages in nixpkgs.
func (n *NixClient) searchPackages(ctx context.Context, task *NixTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if task.Expression == "" </span><span class="cov0" title="0">{
                return nil, xerrors.New("search query is required in expression field")
        }</span>

        <span class="cov0" title="0">args := []string{"search"}

        if n.cfg.FlakesEnabled </span><span class="cov0" title="0">{
                args = append(args, "--experimental-features", "nix-command flakes")
                // Search in nixpkgs flake by default
                nixpkgs := task.Nixpkgs
                if nixpkgs == "" </span><span class="cov0" title="0">{
                        nixpkgs = "nixpkgs"
                }</span>
                <span class="cov0" title="0">args = append(args, nixpkgs, task.Expression)</span>
        } else<span class="cov0" title="0"> {
                // Use nix-env for search
                args = []string{"env", "-qa", fmt.Sprintf(".*%s.*", task.Expression)}
        }</span>

        // Add extra arguments
        <span class="cov0" title="0">args = append(args, task.Args...)

        output, err := n.execNixCommand(ctx, task, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to search packages: %w", err)
        }</span>

        // Parse search results
        <span class="cov0" title="0">lines := strings.Split(strings.TrimSpace(output), "\n")
        var packages []string
        for _, line := range lines </span><span class="cov0" title="0">{
                if line != "" </span><span class="cov0" title="0">{
                        packages = append(packages, strings.TrimSpace(line))
                }</span>
        }

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":   "search",
                "query":    task.Expression,
                "packages": packages,
                "output":   output,
        }

        return result, nil</span>
}

// systemInfo gets NixOS system information.
func (n *NixClient) systemInfo(ctx context.Context, task *NixTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        result := make(map[string]interface{})

        // Get current generation
        output, err := n.execCommand(ctx, task, "nix-env", "--list-generations", "--profile", "/nix/var/nix/profiles/system")
        if err == nil </span><span class="cov0" title="0">{
                lines := strings.Split(strings.TrimSpace(output), "\n")
                if len(lines) &gt; 0 </span><span class="cov0" title="0">{
                        // Parse current generation from last line
                        lastLine := lines[len(lines)-1]
                        if strings.Contains(lastLine, "(current)") </span><span class="cov0" title="0">{
                                parts := strings.Fields(lastLine)
                                if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                        result["current_generation"] = parts[0]
                                }</span>
                        }
                }
                <span class="cov0" title="0">result["generations"] = lines</span>
        }

        // Get nixos-version
        <span class="cov0" title="0">if output, err := n.execCommand(ctx, task, "nixos-version"); err == nil </span><span class="cov0" title="0">{
                result["nixos_version"] = strings.TrimSpace(output)
        }</span>

        // Get kernel version
        <span class="cov0" title="0">if output, err := n.execCommand(ctx, task, "uname", "-r"); err == nil </span><span class="cov0" title="0">{
                result["kernel_version"] = strings.TrimSpace(output)
        }</span>

        // Get store info
        <span class="cov0" title="0">if output, err := n.execNixCommand(ctx, task, "store", "info"); err == nil </span><span class="cov0" title="0">{
                result["store_info"] = strings.TrimSpace(output)
        }</span>

        <span class="cov0" title="0">result["action"] = "info"
        return result, nil</span>
}

// storeOperation performs Nix store operations.
func (n *NixClient) storeOperation(ctx context.Context, task *NixTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        storeAction := "info"
        if task.Config != nil </span><span class="cov0" title="0">{
                if action, ok := task.Config["store_action"].(string); ok </span><span class="cov0" title="0">{
                        storeAction = action
                }</span>
        }

        <span class="cov0" title="0">args := []string{"store", storeAction}

        // Add store path if specified
        if task.Config != nil </span><span class="cov0" title="0">{
                if storePath, ok := task.Config["store_path"].(string); ok &amp;&amp; storePath != "" </span><span class="cov0" title="0">{
                        args = append(args, storePath)
                }</span>
        }

        // Add extra arguments
        <span class="cov0" title="0">args = append(args, task.Args...)

        output, err := n.execNixCommand(ctx, task, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to execute store operation: %w", err)
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "action":       "store",
                "store_action": storeAction,
                "output":       output,
        }

        return result, nil</span>
}

// execNixCommand executes a nix command.
func (n *NixClient) execNixCommand(ctx context.Context, task *NixTask, args ...string) (string, error) <span class="cov0" title="0">{
        return n.execCommand(ctx, task, "nix", args...)
}</span>

// execNixOSCommand executes a nixos-rebuild command.
func (n *NixClient) execNixOSCommand(ctx context.Context, task *NixTask, args ...string) (string, error) <span class="cov0" title="0">{
        return n.execCommand(ctx, task, "nixos-rebuild", args...)
}</span>

// execCommand executes a command with proper environment setup.
func (n *NixClient) execCommand(ctx context.Context, task *NixTask, command string, args ...string) (string, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, command, args...)

        // Set working directory
        if task.WorkDir != "" </span><span class="cov0" title="0">{
                cmd.Dir = task.WorkDir
        }</span>

        // Setup environment
        <span class="cov0" title="0">env := os.Environ()

        // Add NIX_PATH if configured
        if n.cfg.NixPath != "" </span><span class="cov0" title="0">{
                env = append(env, fmt.Sprintf("NIX_PATH=%s", n.cfg.NixPath))
        }</span>

        // Add custom environment variables
        <span class="cov0" title="0">for key, value := range task.Environment </span><span class="cov0" title="0">{
                env = append(env, fmt.Sprintf("%s=%s", key, value))
        }</span>

        // Add signing key if configured
        <span class="cov0" title="0">if n.cfg.SigningKey != "" </span><span class="cov0" title="0">{
                env = append(env, fmt.Sprintf("NIX_SECRET_KEY_FILE=%s", n.cfg.SigningKey))
        }</span>

        <span class="cov0" title="0">cmd.Env = env

        var stdout, stderr strings.Builder
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return "", xerrors.Errorf("command failed: %w, stderr: %s", err, stderr.String())
        }</span>

        <span class="cov0" title="0">return stdout.String(), nil</span>
}

// isFlakesEnabled checks if Nix flakes are enabled.
func isFlakesEnabled() bool <span class="cov0" title="0">{
        // Check nix.conf for experimental-features
        nixConf := "/etc/nix/nix.conf"
        if _, err := os.Stat(nixConf); err == nil </span><span class="cov0" title="0">{
                content, err := os.ReadFile(nixConf)
                if err == nil </span><span class="cov0" title="0">{
                        return strings.Contains(string(content), "experimental-features") &amp;&amp;
                                strings.Contains(string(content), "flakes")
                }</span>
        }

        // Check user config
        <span class="cov0" title="0">home, err := os.UserHomeDir()
        if err == nil </span><span class="cov0" title="0">{
                userNixConf := filepath.Join(home, ".config", "nix", "nix.conf")
                if content, err := os.ReadFile(userNixConf); err == nil </span><span class="cov0" title="0">{
                        return strings.Contains(string(content), "experimental-features") &amp;&amp;
                                strings.Contains(string(content), "flakes")
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// mergeEnvMaps merges two environment variable maps.
func mergeEnvMaps(base, override map[string]string) map[string]string <span class="cov0" title="0">{
        result := make(map[string]string)

        // Copy base map
        for k, v := range base </span><span class="cov0" title="0">{
                result[k] = v
        }</span>

        // Override with new values
        <span class="cov0" title="0">for k, v := range override </span><span class="cov0" title="0">{
                result[k] = v
        }</span>

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package agentic provides an OpenCode agent connector.
package agentic

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "io"
        "log"
        "net/http"
        "time"
)

// OpenCodeConfig holds OpenCode API config.
type OpenCodeConfig struct {
        APIKey   string
        Endpoint string // REST endpoint, e.g. https://api.opencode.ai/v1/agent/invoke
        WSURL    string // WebSocket endpoint, optional
}

// OpenCodeClient implements the Agent interface for OpenCode.
type OpenCodeClient struct {
        cfg OpenCodeConfig
}

func NewOpenCodeClient(cfg OpenCodeConfig) *OpenCodeClient <span class="cov0" title="0">{
        return &amp;OpenCodeClient{cfg: cfg}
}</span>

func (o *OpenCodeClient) Name() string <span class="cov0" title="0">{ return "opencode" }</span>

func (o *OpenCodeClient) Supports(taskType string) bool <span class="cov0" title="0">{
        return taskType == "opencode" || taskType == "llm" || taskType == "plugin"
}</span>

func (o *OpenCodeClient) Execute(ctx context.Context, task *Task) (*TaskResult, error) <span class="cov0" title="0">{
        endpoint := o.cfg.Endpoint
        if endpoint == "" </span><span class="cov0" title="0">{
                return nil, errors.New("OpenCode endpoint not configured")
        }</span>
        <span class="cov0" title="0">payload, err := json.Marshal(task.Payload)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[opencode] marshal error: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", endpoint, bytes.NewReader(payload))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[opencode] request error: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+o.cfg.APIKey)
        req.Header.Set("Content-Type", "application/json")
        client := &amp;http.Client{Timeout: 60 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[opencode] http error: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        body, _ := io.ReadAll(resp.Body)
        if resp.StatusCode != 200 </span><span class="cov0" title="0">{
                log.Printf("[opencode] API error: %s", string(body))
                return &amp;TaskResult{Error: errors.New(string(body))}, nil
        }</span>
        <span class="cov0" title="0">var out interface{}
        if err := json.Unmarshal(body, &amp;out); err != nil </span><span class="cov0" title="0">{
                return &amp;TaskResult{Output: string(body)}, nil
        }</span>
        <span class="cov0" title="0">return &amp;TaskResult{Output: out}, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package agentic provides a Proxmox VE connector for VM/container orchestration.
package agentic

import (
        "bytes"
        "context"
        "crypto/tls"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "time"

        "golang.org/x/xerrors"
)

// ProxmoxConfig holds Proxmox VE API configuration.
type ProxmoxConfig struct {
        URL      string // Proxmox VE API URL (e.g., https://pve.example.com:8006)
        Username string // Username (e.g., root@pam)
        Password string // Password or API token secret
        Token    string // API token (alternative to password)
        Node     string // Default node name
        Insecure bool   // Skip TLS verification (for testing)
}

// ProxmoxClient is an agent for Proxmox VE VM/container orchestration tasks.
type ProxmoxClient struct {
        cfg        ProxmoxConfig
        httpClient *http.Client
        ticket     string    // Authentication ticket
        csrfToken  string    // CSRF prevention token
        ticketExp  time.Time // Ticket expiration
}

// ProxmoxTask represents a Proxmox orchestration task.
type ProxmoxTask struct {
        Action            string                 `json:"action"`   // create, start, stop, delete, list
        VMType            string                 `json:"vm_type"`  // qemu, lxc
        VMID              int                    `json:"vmid"`     // Virtual machine ID
        Node              string                 `json:"node"`     // Proxmox node name
        Template          string                 `json:"template"` // Template name/ID
        Config            map[string]interface{} `json:"config"`   // VM/container configuration
        WaitForCompletion bool                   `json:"wait"`     // Wait for task completion
        GPUs              *ProxmoxGPUConfig      `json:"gpus"`     // GPU passthrough configuration
}

// ProxmoxVM represents a Proxmox virtual machine or container.
type ProxmoxVM struct {
        VMID   int    `json:"vmid"`
        Name   string `json:"name"`
        Status string `json:"status"`
        Type   string `json:"type"` // qemu, lxc
        Node   string `json:"node"`
        CPU    int    `json:"cpu"`
        Memory int    `json:"memory"`
        Disk   string `json:"disk"`
        Uptime int    `json:"uptime"`
}

// ProxmoxTaskStatus represents a Proxmox task status.
type ProxmoxTaskStatus struct {
        UPID      string `json:"upid"`
        Type      string `json:"type"`
        Status    string `json:"status"`
        ExitCode  string `json:"exitstatus,omitempty"`
        StartTime int    `json:"starttime"`
        EndTime   int    `json:"endtime,omitempty"`
}

// ProxmoxGPUConfig represents GPU passthrough configuration for Proxmox VMs.
type ProxmoxGPUConfig struct {
        Enabled    bool     `json:"enabled"`     // Enable GPU passthrough
        PCIDevices []string `json:"pci_devices"` // PCI device IDs (e.g., "01:00.0")
        GPUIDs     []int    `json:"gpu_ids"`     // GPU IDs to passthrough
        VFIO       bool     `json:"vfio"`        // Use VFIO for passthrough
        Primary    bool     `json:"primary"`     // Set as primary GPU
        ROMBAR     bool     `json:"rombar"`      // Enable ROM BAR
        X_VGA      bool     `json:"x_vga"`       // Enable VGA passthrough
        PrimaryGPU bool     `json:"primary_gpu"` // Configure as primary GPU
}

// NewProxmoxClient creates a new Proxmox VE client.
func NewProxmoxClient(cfg ProxmoxConfig) *ProxmoxClient <span class="cov0" title="0">{
        tr := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: cfg.Insecure},
        }

        return &amp;ProxmoxClient{
                cfg: cfg,
                httpClient: &amp;http.Client{
                        Transport: tr,
                        Timeout:   30 * time.Second,
                },
        }
}</span>

func (p *ProxmoxClient) Name() string <span class="cov0" title="0">{ return "proxmox" }</span>

func (p *ProxmoxClient) Supports(taskType string) bool <span class="cov0" title="0">{
        return taskType == "vm" || taskType == "container" || taskType == "infrastructure"
}</span>

func (p *ProxmoxClient) Execute(ctx context.Context, task *Task) (*TaskResult, error) <span class="cov0" title="0">{
        // Parse task payload
        var proxmoxTask ProxmoxTask
        if err := mapToStruct(task.Payload, &amp;proxmoxTask); err != nil </span><span class="cov0" title="0">{
                return &amp;TaskResult{Error: xerrors.Errorf("invalid task payload: %w", err)}, nil
        }</span>

        // Ensure authentication
        <span class="cov0" title="0">if err := p.authenticate(ctx); err != nil </span><span class="cov0" title="0">{
                return &amp;TaskResult{Error: xerrors.Errorf("authentication failed: %w", err)}, nil
        }</span>

        // Execute based on action
        <span class="cov0" title="0">switch proxmoxTask.Action </span>{
        case "list":<span class="cov0" title="0">
                result, err := p.listVMs(ctx, proxmoxTask.Node)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "create":<span class="cov0" title="0">
                result, err := p.createVM(ctx, &amp;proxmoxTask)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "start":<span class="cov0" title="0">
                result, err := p.startVM(ctx, proxmoxTask.Node, proxmoxTask.VMID, proxmoxTask.VMType)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "stop":<span class="cov0" title="0">
                result, err := p.stopVM(ctx, proxmoxTask.Node, proxmoxTask.VMID, proxmoxTask.VMType)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "delete":<span class="cov0" title="0">
                result, err := p.deleteVM(ctx, proxmoxTask.Node, proxmoxTask.VMID, proxmoxTask.VMType)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        case "status":<span class="cov0" title="0">
                result, err := p.getVMStatus(ctx, proxmoxTask.Node, proxmoxTask.VMID, proxmoxTask.VMType)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;TaskResult{Error: err}, nil
                }</span>
                <span class="cov0" title="0">return &amp;TaskResult{Output: result}, nil</span>

        default:<span class="cov0" title="0">
                return &amp;TaskResult{Error: xerrors.Errorf("unsupported action: %s", proxmoxTask.Action)}, nil</span>
        }
}

// authenticate performs authentication with Proxmox VE API.
func (p *ProxmoxClient) authenticate(ctx context.Context) error <span class="cov0" title="0">{
        // Check if we have a valid ticket
        if time.Now().Before(p.ticketExp) &amp;&amp; p.ticket != "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Use API token if provided
        <span class="cov0" title="0">if p.cfg.Token != "" </span><span class="cov0" title="0">{
                // API tokens don't need authentication tickets
                return nil
        }</span>

        // Authenticate with username/password
        <span class="cov0" title="0">authURL := fmt.Sprintf("%s/api2/json/access/ticket", strings.TrimSuffix(p.cfg.URL, "/"))

        data := url.Values{}
        data.Set("username", p.cfg.Username)
        data.Set("password", p.cfg.Password)

        req, err := http.NewRequestWithContext(ctx, "POST", authURL, strings.NewReader(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return xerrors.Errorf("failed to create auth request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        resp, err := p.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return xerrors.Errorf("authentication request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return xerrors.Errorf("authentication failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var authResp struct {
                Data struct {
                        Ticket              string `json:"ticket"`
                        CSRFPreventionToken string `json:"CSRFPreventionToken"`
                } `json:"data"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;authResp); err != nil </span><span class="cov0" title="0">{
                return xerrors.Errorf("failed to decode auth response: %w", err)
        }</span>

        <span class="cov0" title="0">p.ticket = authResp.Data.Ticket
        p.csrfToken = authResp.Data.CSRFPreventionToken
        p.ticketExp = time.Now().Add(2 * time.Hour) // Proxmox tickets are valid for 2 hours

        return nil</span>
}

// makeRequest makes an authenticated request to the Proxmox API.
func (p *ProxmoxClient) makeRequest(ctx context.Context, method, path string, payload interface{}) (*http.Response, error) <span class="cov0" title="0">{
        apiURL := fmt.Sprintf("%s/api2/json%s", strings.TrimSuffix(p.cfg.URL, "/"), path)

        var reqBody io.Reader
        if payload != nil </span><span class="cov0" title="0">{
                data, err := json.Marshal(payload)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, xerrors.Errorf("failed to marshal payload: %w", err)
                }</span>
                <span class="cov0" title="0">reqBody = bytes.NewReader(data)</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, method, apiURL, reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to create request: %w", err)
        }</span>

        // Set authentication headers
        <span class="cov0" title="0">if p.cfg.Token != "" </span><span class="cov0" title="0">{
                // Use API token
                req.Header.Set("Authorization", fmt.Sprintf("PVEAPIToken=%s", p.cfg.Token))
        }</span> else<span class="cov0" title="0"> {
                // Use authentication ticket
                req.Header.Set("Cookie", fmt.Sprintf("PVEAuthCookie=%s", p.ticket))
                if method != "GET" </span><span class="cov0" title="0">{
                        req.Header.Set("CSRFPreventionToken", p.csrfToken)
                }</span>
        }

        <span class="cov0" title="0">if payload != nil </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", "application/json")
        }</span>

        <span class="cov0" title="0">return p.httpClient.Do(req)</span>
}

// listVMs lists all VMs and containers on a node.
func (p *ProxmoxClient) listVMs(ctx context.Context, node string) ([]ProxmoxVM, error) <span class="cov0" title="0">{
        if node == "" </span><span class="cov0" title="0">{
                node = p.cfg.Node
        }</span>

        <span class="cov0" title="0">path := fmt.Sprintf("/nodes/%s/qemu", node)
        resp, err := p.makeRequest(ctx, "GET", path, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to list VMs: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, xerrors.Errorf("API request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var apiResp struct {
                Data []struct {
                        VMID   int    `json:"vmid"`
                        Name   string `json:"name"`
                        Status string `json:"status"`
                        CPU    int    `json:"cpu"`
                        Memory int    `json:"mem"`
                        Disk   int    `json:"disk"`
                        Uptime int    `json:"uptime"`
                } `json:"data"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;apiResp); err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">vms := make([]ProxmoxVM, len(apiResp.Data))
        for i, vm := range apiResp.Data </span><span class="cov0" title="0">{
                vms[i] = ProxmoxVM{
                        VMID:   vm.VMID,
                        Name:   vm.Name,
                        Status: vm.Status,
                        Type:   "qemu",
                        Node:   node,
                        CPU:    vm.CPU,
                        Memory: vm.Memory,
                        Disk:   strconv.Itoa(vm.Disk),
                        Uptime: vm.Uptime,
                }
        }</span>

        // Also list containers
        <span class="cov0" title="0">path = fmt.Sprintf("/nodes/%s/lxc", node)
        resp, err = p.makeRequest(ctx, "GET", path, nil)
        if err != nil </span><span class="cov0" title="0">{
                return vms, nil // Return VMs even if container listing fails
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                var containerResp struct {
                        Data []struct {
                                VMID   int    `json:"vmid"`
                                Name   string `json:"name"`
                                Status string `json:"status"`
                                CPU    int    `json:"cpu"`
                                Memory int    `json:"mem"`
                                Disk   int    `json:"disk"`
                                Uptime int    `json:"uptime"`
                        } `json:"data"`
                }

                if err := json.NewDecoder(resp.Body).Decode(&amp;containerResp); err == nil </span><span class="cov0" title="0">{
                        for _, container := range containerResp.Data </span><span class="cov0" title="0">{
                                vms = append(vms, ProxmoxVM{
                                        VMID:   container.VMID,
                                        Name:   container.Name,
                                        Status: container.Status,
                                        Type:   "lxc",
                                        Node:   node,
                                        CPU:    container.CPU,
                                        Memory: container.Memory,
                                        Disk:   strconv.Itoa(container.Disk),
                                        Uptime: container.Uptime,
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">return vms, nil</span>
}

// createVM creates a new VM or container.
func (p *ProxmoxClient) createVM(ctx context.Context, task *ProxmoxTask) (map[string]interface{}, error) <span class="cov0" title="0">{
        if task.Node == "" </span><span class="cov0" title="0">{
                task.Node = p.cfg.Node
        }</span>

        <span class="cov0" title="0">vmType := task.VMType
        if vmType == "" </span><span class="cov0" title="0">{
                vmType = "qemu" // Default to QEMU VM
        }</span>

        // Build the configuration
        <span class="cov0" title="0">config := make(map[string]interface{})
        if task.Config != nil </span><span class="cov0" title="0">{
                config = task.Config
        }</span>

        // Set VMID if provided
        <span class="cov0" title="0">if task.VMID &gt; 0 </span><span class="cov0" title="0">{
                config["vmid"] = task.VMID
        }</span>

        <span class="cov0" title="0">path := fmt.Sprintf("/nodes/%s/%s", task.Node, vmType)
        resp, err := p.makeRequest(ctx, "POST", path, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to create VM: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, _ := io.ReadAll(resp.Body)
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("VM creation failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        if err := json.Unmarshal(body, &amp;result); err != nil </span><span class="cov0" title="0">{
                return map[string]interface{}{"status": "created", "response": string(body)}, nil
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// startVM starts a VM or container.
func (p *ProxmoxClient) startVM(ctx context.Context, node string, vmid int, vmType string) (map[string]interface{}, error) <span class="cov0" title="0">{
        if node == "" </span><span class="cov0" title="0">{
                node = p.cfg.Node
        }</span>
        <span class="cov0" title="0">if vmType == "" </span><span class="cov0" title="0">{
                vmType = "qemu"
        }</span>

        <span class="cov0" title="0">path := fmt.Sprintf("/nodes/%s/%s/%d/status/start", node, vmType, vmid)
        resp, err := p.makeRequest(ctx, "POST", path, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to start VM: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, _ := io.ReadAll(resp.Body)
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("VM start failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        if err := json.Unmarshal(body, &amp;result); err != nil </span><span class="cov0" title="0">{
                return map[string]interface{}{"status": "started", "vmid": vmid}, nil
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// stopVM stops a VM or container.
func (p *ProxmoxClient) stopVM(ctx context.Context, node string, vmid int, vmType string) (map[string]interface{}, error) <span class="cov0" title="0">{
        if node == "" </span><span class="cov0" title="0">{
                node = p.cfg.Node
        }</span>
        <span class="cov0" title="0">if vmType == "" </span><span class="cov0" title="0">{
                vmType = "qemu"
        }</span>

        <span class="cov0" title="0">path := fmt.Sprintf("/nodes/%s/%s/%d/status/stop", node, vmType, vmid)
        resp, err := p.makeRequest(ctx, "POST", path, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to stop VM: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, _ := io.ReadAll(resp.Body)
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("VM stop failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        if err := json.Unmarshal(body, &amp;result); err != nil </span><span class="cov0" title="0">{
                return map[string]interface{}{"status": "stopped", "vmid": vmid}, nil
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// deleteVM deletes a VM or container.
func (p *ProxmoxClient) deleteVM(ctx context.Context, node string, vmid int, vmType string) (map[string]interface{}, error) <span class="cov0" title="0">{
        if node == "" </span><span class="cov0" title="0">{
                node = p.cfg.Node
        }</span>
        <span class="cov0" title="0">if vmType == "" </span><span class="cov0" title="0">{
                vmType = "qemu"
        }</span>

        <span class="cov0" title="0">path := fmt.Sprintf("/nodes/%s/%s/%d", node, vmType, vmid)
        resp, err := p.makeRequest(ctx, "DELETE", path, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to delete VM: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, _ := io.ReadAll(resp.Body)
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("VM deletion failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        if err := json.Unmarshal(body, &amp;result); err != nil </span><span class="cov0" title="0">{
                return map[string]interface{}{"status": "deleted", "vmid": vmid}, nil
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// getVMStatus gets the status of a VM or container.
func (p *ProxmoxClient) getVMStatus(ctx context.Context, node string, vmid int, vmType string) (map[string]interface{}, error) <span class="cov0" title="0">{
        if node == "" </span><span class="cov0" title="0">{
                node = p.cfg.Node
        }</span>
        <span class="cov0" title="0">if vmType == "" </span><span class="cov0" title="0">{
                vmType = "qemu"
        }</span>

        <span class="cov0" title="0">path := fmt.Sprintf("/nodes/%s/%s/%d/status/current", node, vmType, vmid)
        resp, err := p.makeRequest(ctx, "GET", path, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to get VM status: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, _ := io.ReadAll(resp.Body)
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("VM status request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        if err := json.Unmarshal(body, &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to decode status response: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// mapToStruct converts a map to a struct using JSON marshaling/unmarshaling.
func mapToStruct(m map[string]interface{}, v interface{}) error <span class="cov0" title="0">{
        data, err := json.Marshal(m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(data, v)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package agentic

import (
        "context"
        "encoding/json"
        "log"
        "net/http"
        "os"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        "github.com/go-chi/cors"
        "golang.org/x/xerrors"
)

// ExampleServer demonstrates how to use the agentic auth and secrets system.
type ExampleServer struct {
        secretManager *SecretManager
        authProvider  *GitHubAuthProvider
        config        *Config
        registry      *Registry
        scheduler     *Scheduler
}

// NewExampleServer creates a new example server with authentication and secrets.
func NewExampleServer() (*ExampleServer, error) <span class="cov0" title="0">{
        // Initialize configuration
        config := DefaultConfig()

        // Initialize secret manager with multiple stores
        secretManager := NewSecretManager()
        secretManager.SetLogger(log.Printf)

        // Add environment variable store (highest priority)
        envStore := NewEnvSecretStore()
        secretManager.AddStore("env", envStore)

        // Add file-based encrypted store
        secretsPath := os.Getenv("AGENTIC_SECRETS_FILE")
        if secretsPath == "" </span><span class="cov0" title="0">{
                secretsPath = config.Secrets.File.Path
        }</span>

        <span class="cov0" title="0">secretsPassword := os.Getenv("AGENTIC_SECRETS_PASSWORD")
        if secretsPassword == "" </span><span class="cov0" title="0">{
                secretsPassword = "default-dev-password" // In production, this should be required
        }</span>

        <span class="cov0" title="0">fileStore := NewFileSecretStore(secretsPath, secretsPassword)
        secretManager.AddStore("file", fileStore)

        // Load configuration from secrets
        if err := config.LoadFromSecrets(secretManager); err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to load config from secrets: %w", err)
        }</span>

        // Initialize GitHub OAuth provider
        <span class="cov0" title="0">authProvider := NewGitHubAuthProvider(config.Auth.GitHub, fileStore)
        authProvider.SetLogger(log.Printf)

        // Initialize agent registry and scheduler
        registry := NewRegistry()
        scheduler := NewScheduler(registry, 100)

        // Register HuggingFace connector if API key is available
        if config.HuggingFace.APIKey != "" </span><span class="cov0" title="0">{
                hfClient := NewHFClient(config.HuggingFace)
                registry.Register(hfClient)
                log.Printf("Registered HuggingFace connector")
        }</span>

        <span class="cov0" title="0">return &amp;ExampleServer{
                secretManager: secretManager,
                authProvider:  authProvider,
                config:        config,
                registry:      registry,
                scheduler:     scheduler,
        }, nil</span>
}

// SetupRoutes sets up HTTP routes for the example server.
func (es *ExampleServer) SetupRoutes() http.Handler <span class="cov0" title="0">{
        r := chi.NewRouter()

        // Middleware
        r.Use(middleware.Logger)
        r.Use(middleware.Recoverer)
        r.Use(cors.Handler(cors.Options{
                AllowedOrigins:   []string{"*"}, // Configure appropriately for production
                AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token", "X-Session-ID"},
                ExposedHeaders:   []string{"Link"},
                AllowCredentials: true,
                MaxAge:           300,
        }))

        // Authentication handlers
        authHandler := NewAuthHandler(es.authProvider)
        authHandler.SetLogger(log.Printf)

        r.Route("/auth", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Get("/login", authHandler.LoginHandler)
                r.Get("/callback", authHandler.CallbackHandler)
                r.Post("/logout", authHandler.LogoutHandler)
        }</span>)

        // Protected routes
        <span class="cov0" title="0">r.Route("/api", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Use(es.authProvider.AuthMiddleware())

                r.Get("/user", es.GetUserHandler)
                r.Get("/secrets", es.ListSecretsHandler)
                r.Post("/secrets", es.SetSecretHandler)
                r.Delete("/secrets/{key}", es.DeleteSecretHandler)
                r.Post("/tasks", es.CreateTaskHandler)
                r.Get("/tasks/{id}", es.GetTaskHandler)
        }</span>)

        // Health check (no auth required)
        <span class="cov0" title="0">r.Get("/health", es.HealthHandler)

        return r</span>
}

// GetUserHandler returns current user information.
func (es *ExampleServer) GetUserHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        session, ok := GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "User not found in context", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        writeJSON(w, map[string]interface{}{
                "user": map[string]interface{}{
                        "id":         session.UserID,
                        "login":      session.Login,
                        "email":      session.Email,
                        "name":       session.Name,
                        "avatar_url": session.AvatarURL,
                },
        })</span>
}

// ListSecretsHandler returns a list of secret keys (not values).
func (es *ExampleServer) ListSecretsHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        session, ok := GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        // Only allow listing secrets for authenticated users
        <span class="cov0" title="0">log.Printf("User %s requested secrets list", session.Login)

        // Get keys from file store (don't expose env vars)
        if fileStore, exists := es.secretManager.stores["file"]; exists </span><span class="cov0" title="0">{
                keys, err := fileStore.List()
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Failed to list secrets", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                writeJSON(w, map[string]interface{}{
                        "keys": keys,
                })
                return</span>
        }

        <span class="cov0" title="0">http.Error(w, "Secret store not available", http.StatusInternalServerError)</span>
}

// SetSecretHandler stores a secret.
func (es *ExampleServer) SetSecretHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        session, ok := GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Key   string `json:"key"`
                Value string `json:"value"`
        }

        if err := parseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.Key == "" || req.Value == "" </span><span class="cov0" title="0">{
                http.Error(w, "Key and value are required", http.StatusBadRequest)
                return
        }</span>

        // Store in file store by default
        <span class="cov0" title="0">if err := es.secretManager.Set("file", req.Key, req.Value); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to store secret for user %s: %v", session.Login, err)
                http.Error(w, "Failed to store secret", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("User %s stored secret key: %s", session.Login, req.Key)

        w.Header().Set("Content-Type", "application/json")
        writeJSON(w, map[string]interface{}{
                "success": true,
                "message": "Secret stored successfully",
        })</span>
}

// DeleteSecretHandler deletes a secret.
func (es *ExampleServer) DeleteSecretHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        session, ok := GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">key := chi.URLParam(r, "key")
        if key == "" </span><span class="cov0" title="0">{
                http.Error(w, "Key is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := es.secretManager.Delete("file", key); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to delete secret for user %s: %v", session.Login, err)
                http.Error(w, "Failed to delete secret", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("User %s deleted secret key: %s", session.Login, key)

        w.Header().Set("Content-Type", "application/json")
        writeJSON(w, map[string]interface{}{
                "success": true,
                "message": "Secret deleted successfully",
        })</span>
}

// CreateTaskHandler creates a new agentic task.
func (es *ExampleServer) CreateTaskHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        session, ok := GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Type    string                 `json:"type"`
                Payload map[string]interface{} `json:"payload"`
        }

        if err := parseJSON(r, &amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid JSON", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">task := &amp;Task{
                Type:    req.Type,
                Payload: req.Payload,
                Status:  "queued",
        }

        es.scheduler.Schedule(task)

        log.Printf("User %s created task: %s", session.Login, req.Type)

        w.Header().Set("Content-Type", "application/json")
        writeJSON(w, map[string]interface{}{
                "success": true,
                "task":    task,
        })</span>
}

// GetTaskHandler returns task status (simplified implementation).
func (es *ExampleServer) GetTaskHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        session, ok := GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">taskID := chi.URLParam(r, "id")

        log.Printf("User %s requested task: %s", session.Login, taskID)

        // This is a simplified implementation
        // In a real system, you'd store tasks in a database
        w.Header().Set("Content-Type", "application/json")
        writeJSON(w, map[string]interface{}{
                "id":     taskID,
                "status": "completed",
                "result": "Task completed successfully",
        })</span>
}

// HealthHandler returns server health status.
func (es *ExampleServer) HealthHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        writeJSON(w, map[string]interface{}{
                "status": "healthy",
                "auth":   "enabled",
                "secrets": map[string]interface{}{
                        "env":  true,
                        "file": true,
                },
        })
}</span>

// Start starts the example server.
func (es *ExampleServer) Start(ctx context.Context, addr string) error <span class="cov0" title="0">{
        // Start the scheduler
        es.scheduler.Run(3) // 3 worker goroutines

        // Setup HTTP server
        handler := es.SetupRoutes()
        server := &amp;http.Server{
                Addr:    addr,
                Handler: handler,
        }

        log.Printf("Starting agentic server on %s", addr)
        log.Printf("GitHub OAuth configured: %t", es.config.Auth.GitHub.ClientID != "")

        // Start server in goroutine
        go func() </span><span class="cov0" title="0">{
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Printf("Server error: %v", err)
                }</span>
        }()

        // Wait for context cancellation
        <span class="cov0" title="0">&lt;-ctx.Done()

        log.Printf("Shutting down server...")
        es.scheduler.Stop()
        return server.Shutdown(context.Background())</span>
}

func writeJSON(w http.ResponseWriter, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to encode JSON: %v", err)
        }</span>
}

func parseJSON(r *http.Request, v interface{}) error <span class="cov0" title="0">{
        return json.NewDecoder(r.Body).Decode(v)
}</span>

</pre>
		
		<pre class="file" id="file14" style="display: none">// Package agentic provides examples for GPU connector usage.
package agentic

import (
        "context"
        "fmt"
        "log"
        "time"
)

// ExampleGPUDetection demonstrates basic GPU detection and information gathering.
func ExampleGPUDetection() <span class="cov0" title="0">{
        ctx := context.Background()

        // Create GPU client with default configuration
        gpuConfig := GPUConfig{
                NvidiaSMIPath:    "nvidia-smi",
                DockerRuntime:    "nvidia",
                EnableMonitoring: true,
                MaxGPUsPerTask:   4,
        }

        gpuClient := NewGPUClient(gpuConfig)

        // List available GPUs
        task := &amp;Task{
                Type: "gpu",
                Payload: map[string]interface{}{
                        "action": "list",
                },
        }

        result, err := gpuClient.Execute(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error listing GPUs: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("GPU Detection Result: %+v\n", result.Output)</span>
}

// ExampleGPUInfo demonstrates detailed GPU information retrieval.
func ExampleGPUInfo() <span class="cov0" title="0">{
        ctx := context.Background()

        gpuClient := NewGPUClient(GPUConfig{})

        // Get detailed information for specific GPUs
        task := &amp;Task{
                Type: "gpu",
                Payload: map[string]interface{}{
                        "action":  "info",
                        "gpu_ids": []int{0, 1}, // Target specific GPUs
                },
        }

        result, err := gpuClient.Execute(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting GPU info: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("GPU Info Result: %+v\n", result.Output)</span>
}

// ExampleGPUMonitoring demonstrates GPU monitoring over time.
func ExampleGPUMonitoring() <span class="cov0" title="0">{
        ctx := context.Background()

        gpuClient := NewGPUClient(GPUConfig{})

        // Monitor GPUs for 30 seconds with 5-second intervals
        task := &amp;Task{
                Type: "gpu",
                Payload: map[string]interface{}{
                        "action": "monitor",
                        "monitoring": &amp;GPUMonitoringConfig{
                                Interval:     5 * time.Second,
                                Duration:     30 * time.Second,
                                Metrics:      []string{"utilization", "memory", "temperature"},
                                OutputFormat: "json",
                        },
                },
        }

        result, err := gpuClient.Execute(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error monitoring GPUs: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("GPU Monitoring Result: %+v\n", result.Output)</span>
}

// ExampleCUDAInfo demonstrates CUDA installation detection.
func ExampleCUDAInfo() <span class="cov0" title="0">{
        ctx := context.Background()

        gpuClient := NewGPUClient(GPUConfig{})

        // Get CUDA information
        task := &amp;Task{
                Type: "gpu",
                Payload: map[string]interface{}{
                        "action": "cuda-info",
                },
        }

        result, err := gpuClient.Execute(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting CUDA info: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("CUDA Info Result: %+v\n", result.Output)</span>
}

// ExampleDockerGPUIntegration demonstrates Docker container with GPU support.
func ExampleDockerGPUIntegration() <span class="cov0" title="0">{
        ctx := context.Background()

        // Configure Docker with GPU support
        dockerConfig := DockerConfig{
                Engine: "docker",
        }

        dockerClient := NewDockerClient(dockerConfig)

        // Run a container with GPU access
        task := &amp;Task{
                Type: "container",
                Payload: map[string]interface{}{
                        "action": "run",
                        "image":  "nvidia/cuda:11.8-runtime-ubuntu20.04",
                        "name":   "gpu-test-container",
                        "detach": true,
                        "gpus": &amp;DockerGPUConfig{
                                Enabled:      true,
                                Runtime:      "nvidia",
                                All:          true,
                                Capabilities: []string{"compute", "utility"},
                        },
                        "command": []string{"nvidia-smi"},
                },
        }

        result, err := dockerClient.Execute(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error running GPU container: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Docker GPU Container Result: %+v\n", result.Output)</span>
}

// ExampleKubernetesGPUWorkload demonstrates Kubernetes GPU resource allocation.
func ExampleKubernetesGPUWorkload() <span class="cov0" title="0">{
        ctx := context.Background()

        k8sClient := NewKubernetesClient(KubernetesConfig{})

        // Create a pod with GPU resources
        gpuManifest := `
apiVersion: v1
kind: Pod
metadata:
  name: gpu-workload
  namespace: default
spec:
  containers:
  - name: gpu-container
    image: nvidia/cuda:11.8-runtime-ubuntu20.04
    command: ["nvidia-smi"]
    resources:
      limits:
        nvidia.com/gpu: 1
      requests:
        nvidia.com/gpu: 1
  nodeSelector:
    accelerator: nvidia-tesla-gpu
  tolerations:
  - key: nvidia.com/gpu
    operator: Exists
    effect: NoSchedule
`

        task := &amp;Task{
                Type: "kubernetes",
                Payload: map[string]interface{}{
                        "action":    "apply",
                        "manifest":  gpuManifest,
                        "namespace": "default",
                        "gpus": &amp;K8sGPUConfig{
                                Enabled:      true,
                                ResourceName: "nvidia.com/gpu",
                                Limit:        1,
                                Request:      1,
                                NodeSelector: map[string]string{
                                        "accelerator": "nvidia-tesla-gpu",
                                },
                        },
                },
        }

        result, err := k8sClient.Execute(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating GPU workload: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Kubernetes GPU Workload Result: %+v\n", result.Output)</span>
}

// ExampleProxmoxGPUPassthrough demonstrates Proxmox GPU passthrough configuration.
func ExampleProxmoxGPUPassthrough() <span class="cov0" title="0">{
        ctx := context.Background()

        proxmoxConfig := ProxmoxConfig{
                URL:      "https://pve.example.com:8006",
                Username: "root@pam",
                Node:     "pve-node1",
        }

        proxmoxClient := NewProxmoxClient(proxmoxConfig)

        // Create a VM with GPU passthrough
        task := &amp;Task{
                Type: "vm",
                Payload: map[string]interface{}{
                        "action":  "create",
                        "vm_type": "qemu",
                        "vmid":    100,
                        "node":    "pve-node1",
                        "config": map[string]interface{}{
                                "cores":  4,
                                "memory": 8192,
                                "scsihw": "virtio-scsi-pci",
                                "net0":   "virtio,bridge=vmbr0",
                                "vga":    "none",
                        },
                        "gpus": &amp;ProxmoxGPUConfig{
                                Enabled:    true,
                                PCIDevices: []string{"01:00.0", "01:00.1"}, // GPU and audio device
                                VFIO:       true,
                                Primary:    true,
                                ROMBAR:     true,
                                X_VGA:      true,
                        },
                },
        }

        result, err := proxmoxClient.Execute(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating GPU VM: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Proxmox GPU VM Result: %+v\n", result.Output)</span>
}

// ExampleMLEnvironmentSetup demonstrates ML environment setup with GPU tools.
func ExampleMLEnvironmentSetup() <span class="cov0" title="0">{
        ctx := context.Background()

        // Create GPU client and tools
        gpuClient := NewGPUClient(GPUConfig{})
        gpuTools := NewGPUToolsClient(gpuClient)

        // Define ML environment requirements
        mlConfig := MLEnvironmentConfig{
                GPURequirements: GPURequirements{
                        MinMemoryGB:     8.0,
                        RequiredGPUs:    1,
                        WorkloadType:    "ml",
                        PreferredModels: []string{"RTX", "Tesla", "A100"},
                },
                RequiredCUDAVersion: "11.0",
                Framework:           "pytorch",
                PythonVersion:       "3.9",
                ContainerImage:      "pytorch/pytorch:1.13.1-cuda11.6-cudnn8-runtime",
                WorkspacePath:       "/workspace",
                AdditionalPackages:  []string{"transformers", "datasets", "tensorboard"},
        }

        // Setup ML environment
        result, err := gpuTools.SetupMLEnvironment(ctx, mlConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error setting up ML environment: %v", err)
                return
        }</span>

        <span class="cov0" title="0">if !result.Success </span><span class="cov0" title="0">{
                log.Printf("ML environment setup failed: %s", result.Error)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("ML Environment Setup Result:\n")
        fmt.Printf("Selected GPUs: %+v\n", result.SelectedGPUs)
        fmt.Printf("CUDA Info: %+v\n", result.CUDAInfo)
        fmt.Printf("Environment Variables: %+v\n", result.Environment)
        fmt.Printf("Docker Config: %+v\n", result.DockerRunConfig)
        fmt.Printf("K8s Manifest:\n%s\n", result.K8sManifest)</span>
}

// ExampleGPUAllocation demonstrates GPU allocation for agentic workloads.
func ExampleGPUAllocation() <span class="cov0" title="0">{
        ctx := context.Background()

        gpuClient := NewGPUClient(GPUConfig{})

        // Allocate GPUs for a container
        task := &amp;Task{
                Type: "gpu",
                Payload: map[string]interface{}{
                        "action":       "allocate",
                        "container_id": "my-ml-container",
                        "gpu_ids":      []int{0, 1}, // Allocate specific GPUs
                        "exclusive":    true,
                        "memory":       8192, // 8GB memory limit
                },
        }

        result, err := gpuClient.Execute(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error allocating GPUs: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("GPU Allocation Result: %+v\n", result.Output)

        // Deallocate GPUs when done
        deallocateTask := &amp;Task{
                Type: "gpu",
                Payload: map[string]interface{}{
                        "action":       "deallocate",
                        "container_id": "my-ml-container",
                        "gpu_ids":      []int{0, 1},
                },
        }

        deallocateResult, err := gpuClient.Execute(ctx, deallocateTask)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error deallocating GPUs: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("GPU Deallocation Result: %+v\n", deallocateResult.Output)</span>
}

// ExampleGPUWorkflowOrchestration demonstrates orchestrating a complete GPU workflow.
func ExampleGPUWorkflowOrchestration() <span class="cov0" title="0">{
        ctx := context.Background()

        // Create orchestrator with all connectors
        config := DefaultConfig()
        secretManager := NewSecretManager()

        // Add environment store for secrets
        secretManager.AddStore("env", NewEnvSecretStore())

        orchestrator, err := NewOrchestrator(config, secretManager)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating orchestrator: %v", err)
                return
        }</span>

        // Create a workflow for GPU-enabled ML training
        <span class="cov0" title="0">workflow := &amp;InfrastructureWorkflow{
                ID:          "gpu-ml-training",
                Name:        "GPU ML Training Workflow",
                Description: "Complete workflow for GPU-enabled ML model training",
                Steps: []WorkflowStep{
                        {
                                ID:       "detect-gpus",
                                Name:     "Detect Available GPUs",
                                TaskType: "gpu",
                                Parameters: map[string]interface{}{
                                        "action": "list",
                                },
                        },
                        {
                                ID:        "setup-environment",
                                Name:      "Setup ML Environment",
                                TaskType:  "container",
                                DependsOn: []string{"detect-gpus"},
                                Parameters: map[string]interface{}{
                                        "action": "run",
                                        "image":  "pytorch/pytorch:latest",
                                        "name":   "ml-training",
                                        "detach": true,
                                        "gpus": map[string]interface{}{
                                                "enabled": true,
                                                "all":     true,
                                                "runtime": "nvidia",
                                        },
                                        "volumes": []string{"/data:/workspace/data"},
                                },
                        },
                        {
                                ID:        "monitor-training",
                                Name:      "Monitor GPU Usage",
                                TaskType:  "gpu",
                                DependsOn: []string{"setup-environment"},
                                Parameters: map[string]interface{}{
                                        "action": "monitor",
                                        "monitoring": map[string]interface{}{
                                                "interval": "10s",
                                                "duration": "5m",
                                                "metrics":  []string{"utilization", "memory", "temperature"},
                                        },
                                },
                        },
                },
        }

        // Execute the workflow
        result, err := orchestrator.ExecuteInfrastructureWorkflow(ctx, workflow)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing GPU workflow: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("GPU Workflow Result:\n")
        fmt.Printf("Status: %s\n", result.Status)
        for _, step := range result.Steps </span><span class="cov0" title="0">{
                fmt.Printf("Step %s (%s): %s\n", step.StepID, step.Name, step.Status)
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package agentic provides examples for infrastructure orchestration.
package agentic

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "os"

        "golang.org/x/xerrors"
)

// InfrastructureExample demonstrates Step 2 infrastructure orchestration capabilities.
func InfrastructureExample() error <span class="cov0" title="0">{
        ctx := context.Background()

        // Initialize configuration
        config := DefaultConfig()

        // Create secret manager
        secretManager := NewSecretManager()
        secretManager.AddStore("env", NewEnvSecretStore())

        // Load configuration from secrets
        if err := config.LoadFromSecrets(secretManager); err != nil </span><span class="cov0" title="0">{
                return xerrors.Errorf("failed to load secrets: %w", err)
        }</span>

        // Create orchestrator
        <span class="cov0" title="0">orchestrator, err := NewOrchestrator(config, secretManager)
        if err != nil </span><span class="cov0" title="0">{
                return xerrors.Errorf("failed to create orchestrator: %w", err)
        }</span>

        // Print available connectors
        <span class="cov0" title="0">fmt.Println("=== Available Infrastructure Connectors ===")
        connectors := orchestrator.ListConnectors()
        for _, connector := range connectors </span><span class="cov0" title="0">{
                connectorJSON, _ := json.MarshalIndent(connector, "", "  ")
                fmt.Printf("%s\n", connectorJSON)
        }</span>

        // Example 1: Proxmox VM Management
        <span class="cov0" title="0">if err := demonstrateProxmoxOperations(ctx, orchestrator); err != nil </span><span class="cov0" title="0">{
                log.Printf("Proxmox demo failed: %v", err)
        }</span>

        // Example 2: Docker Container Operations
        <span class="cov0" title="0">if err := demonstrateDockerOperations(ctx, orchestrator); err != nil </span><span class="cov0" title="0">{
                log.Printf("Docker demo failed: %v", err)
        }</span>

        // Example 3: Kubernetes Operations
        <span class="cov0" title="0">if err := demonstrateKubernetesOperations(ctx, orchestrator); err != nil </span><span class="cov0" title="0">{
                log.Printf("Kubernetes demo failed: %v", err)
        }</span>

        // Example 4: Complex Infrastructure Workflow
        <span class="cov0" title="0">if err := demonstrateInfrastructureWorkflow(ctx, orchestrator); err != nil </span><span class="cov0" title="0">{
                log.Printf("Infrastructure workflow demo failed: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// demonstrateProxmoxOperations shows Proxmox VM management.
func demonstrateProxmoxOperations(ctx context.Context, orchestrator *Orchestrator) error <span class="cov0" title="0">{
        fmt.Println("\n=== Proxmox Operations Demo ===")

        // List VMs
        listTask := &amp;Task{
                Type: "vm",
                Payload: map[string]interface{}{
                        "action": "list",
                        "node":   "pve", // Default node
                },
        }

        result, err := orchestrator.ExecuteTask(ctx, listTask)
        if err != nil </span><span class="cov0" title="0">{
                return xerrors.Errorf("failed to list VMs: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("VMs: %+v\n", result.Output)

        // Create a test VM (commented out to avoid actual creation)
        /*
                createTask := &amp;Task{
                        Type: "vm",
                        Payload: map[string]interface{}{
                                "action":   "create",
                                "vm_type":  "qemu",
                                "vmid":     9999,
                                "node":     "pve",
                                "config": map[string]interface{}{
                                        "cores":   2,
                                        "memory":  2048,
                                        "scsihw":  "virtio-scsi-pci",
                                        "net0":    "virtio,bridge=vmbr0",
                                        "ide2":    "local:iso/ubuntu-20.04.iso,media=cdrom",
                                },
                        },
                }

                result, err = orchestrator.ExecuteTask(ctx, createTask)
                if err != nil {
                        return fmt.Errorf("failed to create VM: %w", err)
                }

                fmt.Printf("VM Creation Result: %+v\n", result.Output)
        */

        return nil</span>
}

// demonstrateDockerOperations shows Docker container management.
func demonstrateDockerOperations(ctx context.Context, orchestrator *Orchestrator) error <span class="cov0" title="0">{
        fmt.Println("\n=== Docker Operations Demo ===")

        // List containers
        listTask := &amp;Task{
                Type: "container",
                Payload: map[string]interface{}{
                        "action": "ps",
                        "config": map[string]interface{}{
                                "all": true,
                        },
                },
        }

        result, err := orchestrator.ExecuteTask(ctx, listTask)
        if err != nil </span><span class="cov0" title="0">{
                return xerrors.Errorf("failed to list containers: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Containers: %+v\n", result.Output)

        // Pull a test image
        pullTask := &amp;Task{
                Type: "container",
                Payload: map[string]interface{}{
                        "action": "pull",
                        "image":  "hello-world",
                },
        }

        result, err = orchestrator.ExecuteTask(ctx, pullTask)
        if err != nil </span><span class="cov0" title="0">{
                return xerrors.Errorf("failed to pull image: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Image Pull Result: %+v\n", result.Output)

        // Run a test container
        runTask := &amp;Task{
                Type: "container",
                Payload: map[string]interface{}{
                        "action": "run",
                        "image":  "hello-world",
                        "name":   "agentic-test",
                        "remove": true, // Auto-remove when done
                },
        }

        result, err = orchestrator.ExecuteTask(ctx, runTask)
        if err != nil </span><span class="cov0" title="0">{
                return xerrors.Errorf("failed to run container: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Container Run Result: %+v\n", result.Output)

        return nil</span>
}

// demonstrateKubernetesOperations shows Kubernetes cluster management.
func demonstrateKubernetesOperations(ctx context.Context, orchestrator *Orchestrator) error <span class="cov0" title="0">{
        fmt.Println("\n=== Kubernetes Operations Demo ===")

        // Get cluster info
        clusterInfoTask := &amp;Task{
                Type: "kubernetes",
                Payload: map[string]interface{}{
                        "action": "cluster-info",
                },
        }

        result, err := orchestrator.ExecuteTask(ctx, clusterInfoTask)
        if err != nil </span><span class="cov0" title="0">{
                return xerrors.Errorf("failed to get cluster info: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Cluster Info: %+v\n", result.Output)

        // List pods
        listPodsTask := &amp;Task{
                Type: "kubernetes",
                Payload: map[string]interface{}{
                        "action":    "get",
                        "resource":  "pods",
                        "namespace": "default",
                },
        }

        result, err = orchestrator.ExecuteTask(ctx, listPodsTask)
        if err != nil </span><span class="cov0" title="0">{
                return xerrors.Errorf("failed to list pods: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Pods: %+v\n", result.Output)

        // Deploy a test pod
        testPodManifest := `
apiVersion: v1
kind: Pod
metadata:
  name: agentic-test-pod
  namespace: default
spec:
  containers:
  - name: test-container
    image: busybox
    command: ['sh', '-c', 'echo "Hello from Agentic!" &amp;&amp; sleep 30']
  restartPolicy: Never
`

        deployTask := &amp;Task{
                Type: "kubernetes",
                Payload: map[string]interface{}{
                        "action":    "apply",
                        "manifest":  testPodManifest,
                        "namespace": "default",
                },
        }

        result, err = orchestrator.ExecuteTask(ctx, deployTask)
        if err != nil </span><span class="cov0" title="0">{
                return xerrors.Errorf("failed to deploy test pod: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Pod Deploy Result: %+v\n", result.Output)

        // Clean up the test pod after demo
        deleteTask := &amp;Task{
                Type: "kubernetes",
                Payload: map[string]interface{}{
                        "action":    "delete",
                        "resource":  "pod",
                        "name":      "agentic-test-pod",
                        "namespace": "default",
                },
        }

        result, err = orchestrator.ExecuteTask(ctx, deleteTask)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to clean up test pod: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Pod Cleanup Result: %+v\n", result.Output)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// demonstrateInfrastructureWorkflow shows a complex multi-step infrastructure workflow.
func demonstrateInfrastructureWorkflow(ctx context.Context, orchestrator *Orchestrator) error <span class="cov0" title="0">{
        fmt.Println("\n=== Infrastructure Workflow Demo ===")

        // Create a workflow that combines multiple infrastructure operations
        workflow := CreateVMWorkflow(VMWorkflowConfig{
                Name:        "test-stack",
                VMID:        9998,
                CPU:         2,
                Memory:      2048,
                UseProxmox:  false, // Set to true if Proxmox is available
                ProxmoxNode: "pve",
                Containers: []ContainerConfig{
                        {
                                Name:  "web-server",
                                Image: "nginx:alpine",
                                Ports: []string{"8080:80"},
                                Environment: map[string]string{
                                        "NGINX_HOST": "localhost",
                                        "NGINX_PORT": "80",
                                },
                        },
                        {
                                Name:  "redis-cache",
                                Image: "redis:alpine",
                                Ports: []string{"6379:6379"},
                        },
                },
                KubernetesManifests: []K8sManifestConfig{
                        {
                                Name:      "test-configmap",
                                Namespace: "default",
                                YAML: `
apiVersion: v1
kind: ConfigMap
metadata:
  name: agentic-config
  namespace: default
data:
  app.properties: |
    app.name=agentic-test
    app.version=1.0.0
`,
                        },
                },
        })

        fmt.Printf("Created workflow: %s\n", workflow.Name)
        fmt.Printf("Workflow steps: %d\n", len(workflow.Steps))

        // Execute the workflow
        workflowResult, err := orchestrator.ExecuteInfrastructureWorkflow(ctx, workflow)
        if err != nil </span><span class="cov0" title="0">{
                return xerrors.Errorf("workflow execution failed: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Workflow Status: %s\n", workflowResult.Status)
        for _, step := range workflowResult.Steps </span><span class="cov0" title="0">{
                fmt.Printf("  Step %d (%s): %s\n", step.Order, step.Name, step.Status)
                if step.Error != "" </span><span class="cov0" title="0">{
                        fmt.Printf("    Error: %s\n", step.Error)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// RunInfrastructureServer creates and runs a complete infrastructure management server.
func RunInfrastructureServer(ctx context.Context, addr string) error <span class="cov0" title="0">{
        // This would typically set up HTTP handlers for infrastructure management
        // For now, we'll just run the example

        fmt.Printf("Starting Agentic Infrastructure Server on %s\n", addr)
        fmt.Println("Step 2: Container, VM, and Cluster Integration - IMPLEMENTED")

        // Run the infrastructure example
        if err := InfrastructureExample(); err != nil </span><span class="cov0" title="0">{
                return xerrors.Errorf("infrastructure example failed: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("\n=== Infrastructure Connectors Successfully Implemented ===")
        fmt.Println(" Proxmox Integration: VM/container orchestration via Proxmox API")
        fmt.Println(" Docker &amp; Podman: Full support for Compose, Swarm, Podman CLI/API")
        fmt.Println(" Kubernetes Family: kubectl, MicroK8s, K3s, and Talos support")
        fmt.Println(" Unified Orchestration: Multi-step infrastructure workflows")
        fmt.Println(" Secure Credentials: Environment variables and encrypted storage")

        // Keep server running
        fmt.Println("\nInfrastructure server ready. Press Ctrl+C to stop.")
        &lt;-ctx.Done()

        return nil</span>
}

// ExampleMain demonstrates how to use the new infrastructure capabilities.
func ExampleMain() <span class="cov0" title="0">{
        // Check if this is being run as a standalone example
        if len(os.Args) &gt; 1 &amp;&amp; os.Args[1] == "infrastructure" </span><span class="cov0" title="0">{
                ctx := context.Background()

                if err := RunInfrastructureServer(ctx, ":8080"); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Infrastructure server failed: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Run just the infrastructure example
                if err := InfrastructureExample(); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Infrastructure example failed: %v", err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package agentic provides Nix/NixOS infrastructure examples.
package agentic

import (
        "context"
        "fmt"
        "log"

        "golang.org/x/xerrors"
)

// NixExampleConfig demonstrates Nix/NixOS workflow configuration.
type NixExampleConfig struct {
        FlakeRef    string `json:"flake_ref"`
        RemoteHost  string `json:"remote_host"`
        RemoteUser  string `json:"remote_user"`
        SSHKeyPath  string `json:"ssh_key_path"`
        Environment string `json:"environment"` // development, staging, production
}

// RunNixExamples demonstrates various Nix/NixOS operations.
func RunNixExamples(ctx context.Context, orchestrator *Orchestrator) error <span class="cov0" title="0">{
        log.Println("=== Nix/NixOS Infrastructure Examples ===")

        // Example 1: Build a simple package
        log.Println("\n1. Building a Nix package...")
        buildTask := &amp;Task{
                Type: "nix",
                Payload: map[string]interface{}{
                        "action":    "build",
                        "flake_ref": "nixpkgs#hello",
                        "system":    "x86_64-linux",
                },
        }

        result, err := orchestrator.ExecuteTask(ctx, buildTask)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Build failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Build result: %+v", result.Output)
        }</span>

        // Example 2: Create a development environment
        <span class="cov0" title="0">log.Println("\n2. Creating a development environment...")
        devTask := &amp;Task{
                Type: "nix",
                Payload: map[string]interface{}{
                        "action":    "develop",
                        "flake_ref": "github:nixos/templates#python",
                        "config": map[string]interface{}{
                                "command": "python --version",
                        },
                },
        }

        result, err = orchestrator.ExecuteTask(ctx, devTask)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Development environment failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Development environment result: %+v", result.Output)
        }</span>

        // Example 3: NixOS system rebuild
        <span class="cov0" title="0">log.Println("\n3. NixOS system rebuild...")
        rebuildTask := &amp;Task{
                Type: "nixos",
                Payload: map[string]interface{}{
                        "action":    "rebuild",
                        "flake_ref": "/etc/nixos",
                        "config": map[string]interface{}{
                                "rebuild_action": "dry-run", // Safe dry run
                        },
                },
        }

        result, err = orchestrator.ExecuteTask(ctx, rebuildTask)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("NixOS rebuild failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("NixOS rebuild result: %+v", result.Output)
        }</span>

        // Example 4: Search packages
        <span class="cov0" title="0">log.Println("\n4. Searching for packages...")
        searchTask := &amp;Task{
                Type: "nix",
                Payload: map[string]interface{}{
                        "action":     "search",
                        "expression": "python3",
                        "nixpkgs":    "nixpkgs",
                },
        }

        result, err = orchestrator.ExecuteTask(ctx, searchTask)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Package search failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Search result: %+v", result.Output)
        }</span>

        // Example 5: Flake operations
        <span class="cov0" title="0">log.Println("\n5. Flake metadata...")
        flakeTask := &amp;Task{
                Type: "nix",
                Payload: map[string]interface{}{
                        "action":    "flake",
                        "flake_ref": "nixpkgs",
                        "config": map[string]interface{}{
                                "flake_action": "metadata",
                        },
                },
        }

        result, err = orchestrator.ExecuteTask(ctx, flakeTask)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Flake operation failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Flake metadata: %+v", result.Output)
        }</span>

        // Example 6: Store operations
        <span class="cov0" title="0">log.Println("\n6. Store information...")
        storeTask := &amp;Task{
                Type: "nix",
                Payload: map[string]interface{}{
                        "action": "store",
                        "config": map[string]interface{}{
                                "store_action": "info",
                        },
                },
        }

        result, err = orchestrator.ExecuteTask(ctx, storeTask)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Store operation failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Store info: %+v", result.Output)
        }</span>

        // Example 7: System information
        <span class="cov0" title="0">log.Println("\n7. System information...")
        infoTask := &amp;Task{
                Type: "nixos",
                Payload: map[string]interface{}{
                        "action": "info",
                },
        }

        result, err = orchestrator.ExecuteTask(ctx, infoTask)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("System info failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("System info: %+v", result.Output)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateNixWorkflow creates a comprehensive Nix-based infrastructure workflow.
func CreateNixWorkflow(config NixExampleConfig) *InfrastructureWorkflow <span class="cov0" title="0">{
        workflow := &amp;InfrastructureWorkflow{
                ID:          fmt.Sprintf("nix-deploy-%s", config.Environment),
                Name:        fmt.Sprintf("Nix Infrastructure Deployment - %s", config.Environment),
                Description: "Complete Nix-based infrastructure deployment with reproducible builds",
                Steps:       []WorkflowStep{},
        }

        // Step 1: Build the system configuration
        workflow.Steps = append(workflow.Steps, WorkflowStep{
                ID:       "build-system",
                Name:     "Build NixOS Configuration",
                TaskType: "nix",
                Parameters: map[string]interface{}{
                        "action":    "build",
                        "flake_ref": fmt.Sprintf("%s#nixosConfigurations.%s", config.FlakeRef, config.Environment),
                        "system":    "x86_64-linux",
                },
        })

        // Step 2: Deploy to remote host if specified
        if config.RemoteHost != "" </span><span class="cov0" title="0">{
                workflow.Steps = append(workflow.Steps, WorkflowStep{
                        ID:        "deploy-remote",
                        Name:      "Deploy to Remote Host",
                        TaskType:  "nix",
                        DependsOn: []string{"build-system"},
                        Parameters: map[string]interface{}{
                                "action":    "deploy",
                                "flake_ref": fmt.Sprintf("%s#nixosConfigurations.%s", config.FlakeRef, config.Environment),
                                "remote": map[string]interface{}{
                                        "host":    config.RemoteHost,
                                        "user":    config.RemoteUser,
                                        "ssh_key": config.SSHKeyPath,
                                },
                        },
                })
        }</span>

        // Step 3: Build and deploy application containers
        <span class="cov0" title="0">workflow.Steps = append(workflow.Steps, WorkflowStep{
                ID:       "build-apps",
                Name:     "Build Application Containers",
                TaskType: "nix",
                DependsOn: func() []string </span><span class="cov0" title="0">{
                        if config.RemoteHost != "" </span><span class="cov0" title="0">{
                                return []string{"deploy-remote"}
                        }</span>
                        <span class="cov0" title="0">return []string{"build-system"}</span>
                }(),
                Parameters: map[string]interface{}{
                        "action":    "build",
                        "flake_ref": fmt.Sprintf("%s#packages.x86_64-linux", config.FlakeRef),
                },
        })

        // Step 4: Verify deployment
        <span class="cov0" title="0">workflow.Steps = append(workflow.Steps, WorkflowStep{
                ID:        "verify-deployment",
                Name:      "Verify Deployment",
                TaskType:  "nixos",
                DependsOn: []string{"build-apps"},
                Parameters: map[string]interface{}{
                        "action": "info",
                },
        })

        // Step 5: Cleanup old generations
        workflow.Steps = append(workflow.Steps, WorkflowStep{
                ID:        "cleanup",
                Name:      "Cleanup Old Generations",
                TaskType:  "nix",
                DependsOn: []string{"verify-deployment"},
                Parameters: map[string]interface{}{
                        "action": "gc",
                        "config": map[string]interface{}{
                                "max_age": "30d",
                        },
                },
                ContinueOnError: true, // Don't fail workflow if cleanup fails
        })

        return workflow</span>
}

// RunNixInfrastructureDemo demonstrates a complete Nix infrastructure workflow.
func RunNixInfrastructureDemo(ctx context.Context, orchestrator *Orchestrator) error <span class="cov0" title="0">{
        log.Println("=== Nix Infrastructure Workflow Demo ===")

        // Create a sample workflow configuration
        config := NixExampleConfig{
                FlakeRef:    "github:myorg/nixos-infrastructure",
                RemoteHost:  "staging.example.com",
                RemoteUser:  "deploy",
                SSHKeyPath:  "/path/to/deploy.key",
                Environment: "staging",
        }

        // Create the workflow
        workflow := CreateNixWorkflow(config)

        log.Printf("Created workflow: %s", workflow.Name)
        log.Printf("Workflow steps: %d", len(workflow.Steps))

        // Execute the workflow
        result, err := orchestrator.ExecuteInfrastructureWorkflow(ctx, workflow)
        if err != nil </span><span class="cov0" title="0">{
                return xerrors.Errorf("workflow execution failed: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Workflow completed with status: %s", result.Status)
        for i, step := range result.Steps </span><span class="cov0" title="0">{
                log.Printf("Step %d (%s): %s", i+1, step.Name, step.Status)
                if step.Error != "" </span><span class="cov0" title="0">{
                        log.Printf("  Error: %s", step.Error)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ExampleNixFlakeDefinition provides an example flake.nix for infrastructure.
const ExampleNixFlakeDefinition = `{
  description = "Agentic Infrastructure with NixOS";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
      in
      {
        # Development environment
        devShells.default = pkgs.mkShell {
          buildInputs = with pkgs; [
            go
            nix
            nixos-rebuild
            docker
            kubectl
            terraform
          ];

          shellHook = ''
            echo "Agentic Infrastructure Development Environment"
            echo "Available tools: go, nix, docker, kubectl, terraform"
          '';
        };

        # Application packages
        packages = {
          agentic-server = pkgs.buildGoModule {
            pname = "agentic-server";
            version = "0.1.0";
            src = ./.;
            vendorHash = "sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=";
          };

          docker-image = pkgs.dockerTools.buildImage {
            name = "agentic-server";
            tag = "latest";
            contents = [ self.packages.${system}.agentic-server ];
            config = {
              Cmd = [ "/bin/agentic-server" ];
              ExposedPorts = { "8080/tcp" = {}; };
            };
          };
        };
      }) // {
      # NixOS configurations
      nixosConfigurations = {
        staging = nixpkgs.lib.nixosSystem {
          system = "x86_64-linux";
          modules = [
            ./nixos/staging.nix
            {
              services.agentic = {
                enable = true;
                package = self.packages.x86_64-linux.agentic-server;
              };
            }
          ];
        };

        production = nixpkgs.lib.nixosSystem {
          system = "x86_64-linux";
          modules = [
            ./nixos/production.nix
            {
              services.agentic = {
                enable = true;
                package = self.packages.x86_64-linux.agentic-server;
              };
            }
          ];
        };
      };
    };
}`

// ExampleNixOSConfiguration provides an example NixOS system configuration.
const ExampleNixOSConfiguration = `{ config, pkgs, ... }:

{
  # Basic system configuration
  system.stateVersion = "23.11";
  
  # Enable flakes
  nix.settings.experimental-features = [ "nix-command" "flakes" ];
  
  # Networking
  networking = {
    hostName = "agentic-server";
    firewall = {
      enable = true;
      allowedTCPPorts = [ 22 80 443 8080 ];
    };
  };

  # Services
  services = {
    # SSH
    openssh = {
      enable = true;
      settings = {
        PasswordAuthentication = false;
        PermitRootLogin = "no";
      };
    };

    # Docker
    docker = {
      enable = true;
      enableOnBoot = true;
    };

    # Nginx reverse proxy
    nginx = {
      enable = true;
      recommendedGzipSettings = true;
      recommendedOptimisation = true;
      recommendedProxySettings = true;
      recommendedTlsSettings = true;

      virtualHosts."agentic.example.com" = {
        enableACME = true;
        forceSSL = true;
        locations."/" = {
          proxyPass = "http://127.0.0.1:8080";
          proxyWebsockets = true;
        };
      };
    };

    # ACME for SSL certificates
    acme = {
      acceptTerms = true;
      defaults.email = "admin@example.com";
    };
  };

  # System packages
  environment.systemPackages = with pkgs; [
    git
    curl
    htop
    docker-compose
    kubectl
    nix
  ];

  # Users
  users.users.deploy = {
    isNormalUser = true;
    extraGroups = [ "wheel" "docker" ];
    openssh.authorizedKeys.keys = [
      "ssh-rsa AAAAB3NzaC1yc2EAAAA... deploy@agentic"
    ];
  };

  # Security
  security.sudo.wheelNeedsPassword = false;
}`
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package agentic provides GPU tools for agentic workloads and ML/AI tasks.
package agentic

import (
        "context"
        "fmt"

        "golang.org/x/xerrors"
)

// GPUToolsClient provides high-level GPU tools for agentic workloads.
type GPUToolsClient struct {
        gpuClient *GPUClient
}

// NewGPUToolsClient creates a new GPU tools client.
func NewGPUToolsClient(gpuClient *GPUClient) *GPUToolsClient <span class="cov0" title="0">{
        return &amp;GPUToolsClient{
                gpuClient: gpuClient,
        }
}</span>

// CheckGPUAvailability checks if GPUs are available for agentic workloads.
func (g *GPUToolsClient) CheckGPUAvailability(ctx context.Context) (*GPUAvailabilityResult, error) <span class="cov0" title="0">{
        task := &amp;Task{
                Type: "gpu",
                Payload: map[string]interface{}{
                        "action": "list",
                },
        }

        result, err := g.gpuClient.Execute(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;GPUAvailabilityResult{
                        Available: false,
                        Error:     err.Error(),
                }, nil
        }</span>

        <span class="cov0" title="0">gpuData, ok := result.Output.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return &amp;GPUAvailabilityResult{
                        Available: false,
                        Error:     "invalid GPU data format",
                }, nil
        }</span>

        <span class="cov0" title="0">gpuCount, _ := gpuData["gpu_count"].(int)
        gpus, _ := gpuData["gpus"].([]GPUInfo)

        availability := &amp;GPUAvailabilityResult{
                Available:    gpuCount &gt; 0,
                GPUCount:     gpuCount,
                GPUs:         gpus,
                Capabilities: g.detectCapabilities(gpus),
        }

        return availability, nil</span>
}

// SelectOptimalGPUs selects the best GPUs for a specific workload.
func (g *GPUToolsClient) SelectOptimalGPUs(ctx context.Context, requirements GPURequirements) (*GPUSelectionResult, error) <span class="cov0" title="0">{
        // Get available GPUs
        availability, err := g.CheckGPUAvailability(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to check GPU availability: %w", err)
        }</span>

        <span class="cov0" title="0">if !availability.Available </span><span class="cov0" title="0">{
                return &amp;GPUSelectionResult{
                        Success: false,
                        Error:   "no GPUs available",
                }, nil
        }</span>

        // Filter and rank GPUs based on requirements
        <span class="cov0" title="0">candidates := g.filterGPUsByRequirements(availability.GPUs, requirements)
        if len(candidates) == 0 </span><span class="cov0" title="0">{
                return &amp;GPUSelectionResult{
                        Success: false,
                        Error:   "no GPUs meet the requirements",
                }, nil
        }</span>

        // Select the best GPUs
        <span class="cov0" title="0">selected := g.selectBestGPUs(candidates, requirements)

        return &amp;GPUSelectionResult{
                Success:      true,
                SelectedGPUs: selected,
                TotalMemory:  g.calculateTotalMemory(selected),
                Reasoning:    g.generateSelectionReasoning(selected, requirements),
        }, nil</span>
}

// SetupMLEnvironment sets up a GPU-enabled ML/AI environment.
func (g *GPUToolsClient) SetupMLEnvironment(ctx context.Context, config MLEnvironmentConfig) (*MLEnvironmentResult, error) <span class="cov0" title="0">{
        // Check GPU requirements
        gpuSelection, err := g.SelectOptimalGPUs(ctx, config.GPURequirements)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to select GPUs: %w", err)
        }</span>

        <span class="cov0" title="0">if !gpuSelection.Success </span><span class="cov0" title="0">{
                return &amp;MLEnvironmentResult{
                        Success: false,
                        Error:   fmt.Sprintf("GPU selection failed: %s", gpuSelection.Error),
                }, nil
        }</span>

        // Get CUDA info
        <span class="cov0" title="0">cudaTask := &amp;Task{
                Type: "gpu",
                Payload: map[string]interface{}{
                        "action": "cuda-info",
                },
        }

        cudaResult, err := g.gpuClient.Execute(ctx, cudaTask)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;MLEnvironmentResult{
                        Success: false,
                        Error:   fmt.Sprintf("failed to get CUDA info: %v", err),
                }, nil
        }</span>

        <span class="cov0" title="0">cudaData, _ := cudaResult.Output.(map[string]interface{})
        cudaInfo, _ := cudaData["cuda_info"].(CUDAInfo)

        // Validate CUDA version compatibility
        if config.RequiredCUDAVersion != "" &amp;&amp; !g.isCUDAVersionCompatible(cudaInfo.Version, config.RequiredCUDAVersion) </span><span class="cov0" title="0">{
                return &amp;MLEnvironmentResult{
                        Success: false,
                        Error:   fmt.Sprintf("CUDA version %s not compatible with required %s", cudaInfo.Version, config.RequiredCUDAVersion),
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;MLEnvironmentResult{
                Success:         true,
                SelectedGPUs:    gpuSelection.SelectedGPUs,
                CUDAInfo:        cudaInfo,
                Environment:     g.generateMLEnvironment(gpuSelection.SelectedGPUs, cudaInfo, config),
                DockerRunConfig: g.generateDockerConfig(gpuSelection.SelectedGPUs, config),
                K8sManifest:     g.generateK8sManifest(gpuSelection.SelectedGPUs, config),
        }, nil</span>
}

// MonitorGPUWorkload monitors GPU usage for agentic workloads.
func (g *GPUToolsClient) MonitorGPUWorkload(ctx context.Context, config GPUMonitoringConfig) (*GPUMonitoringResult, error) <span class="cov0" title="0">{
        task := &amp;Task{
                Type: "gpu",
                Payload: map[string]interface{}{
                        "action":     "monitor",
                        "monitoring": config,
                },
        }

        result, err := g.gpuClient.Execute(ctx, task)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("failed to monitor GPUs: %w", err)
        }</span>

        <span class="cov0" title="0">monitoringData, ok := result.Output.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, xerrors.New("invalid monitoring data format")
        }</span>

        <span class="cov0" title="0">return &amp;GPUMonitoringResult{
                Success:     true,
                MonitorData: monitoringData,
                Insights:    g.generateMonitoringInsights(monitoringData),
        }, nil</span>
}

// Helper types

// GPUAvailabilityResult represents GPU availability information.
type GPUAvailabilityResult struct {
        Available    bool      `json:"available"`
        GPUCount     int       `json:"gpu_count"`
        GPUs         []GPUInfo `json:"gpus"`
        Capabilities []string  `json:"capabilities"`
        Error        string    `json:"error,omitempty"`
}

// GPURequirements represents requirements for GPU selection.
type GPURequirements struct {
        MinMemoryGB     float64  `json:"min_memory_gb"`
        MinComputeUnits int      `json:"min_compute_units"`
        RequiredGPUs    int      `json:"required_gpus"`
        PreferredModels []string `json:"preferred_models"`
        MaxPowerDraw    float64  `json:"max_power_draw"`
        WorkloadType    string   `json:"workload_type"` // "ml", "ai", "compute", "graphics"
}

// GPUSelectionResult represents the result of GPU selection.
type GPUSelectionResult struct {
        Success      bool      `json:"success"`
        SelectedGPUs []GPUInfo `json:"selected_gpus"`
        TotalMemory  int64     `json:"total_memory_mb"`
        Reasoning    string    `json:"reasoning"`
        Error        string    `json:"error,omitempty"`
}

// MLEnvironmentConfig represents configuration for ML environment setup.
type MLEnvironmentConfig struct {
        GPURequirements     GPURequirements `json:"gpu_requirements"`
        RequiredCUDAVersion string          `json:"required_cuda_version"`
        Framework           string          `json:"framework"` // "pytorch", "tensorflow", "jax"
        PythonVersion       string          `json:"python_version"`
        AdditionalPackages  []string        `json:"additional_packages"`
        ContainerImage      string          `json:"container_image"`
        WorkspacePath       string          `json:"workspace_path"`
}

// MLEnvironmentResult represents the result of ML environment setup.
type MLEnvironmentResult struct {
        Success         bool                   `json:"success"`
        SelectedGPUs    []GPUInfo              `json:"selected_gpus"`
        CUDAInfo        CUDAInfo               `json:"cuda_info"`
        Environment     map[string]string      `json:"environment"`
        DockerRunConfig map[string]interface{} `json:"docker_run_config"`
        K8sManifest     string                 `json:"k8s_manifest"`
        Error           string                 `json:"error,omitempty"`
}

// GPUMonitoringResult represents GPU monitoring results.
type GPUMonitoringResult struct {
        Success     bool                   `json:"success"`
        MonitorData map[string]interface{} `json:"monitor_data"`
        Insights    []string               `json:"insights"`
        Error       string                 `json:"error,omitempty"`
}

// Helper methods

// detectCapabilities detects GPU capabilities.
func (g *GPUToolsClient) detectCapabilities(gpus []GPUInfo) []string <span class="cov0" title="0">{
        capabilities := []string{}

        for _, gpu := range gpus </span><span class="cov0" title="0">{
                if gpu.CUDAVersion != "" </span><span class="cov0" title="0">{
                        capabilities = append(capabilities, "cuda")
                }</span>

                // Check for specific GPU models and their capabilities
                <span class="cov0" title="0">gpuName := gpu.Name
                if contains(gpuName, "RTX") || contains(gpuName, "GTX") </span><span class="cov0" title="0">{
                        capabilities = append(capabilities, "gaming", "compute")
                }</span>
                <span class="cov0" title="0">if contains(gpuName, "Tesla") || contains(gpuName, "V100") || contains(gpuName, "A100") </span><span class="cov0" title="0">{
                        capabilities = append(capabilities, "datacenter", "ml", "ai")
                }</span>
                <span class="cov0" title="0">if contains(gpuName, "Quadro") </span><span class="cov0" title="0">{
                        capabilities = append(capabilities, "professional", "graphics")
                }</span>
        }

        <span class="cov0" title="0">return uniqueStrings(capabilities)</span>
}

// filterGPUsByRequirements filters GPUs based on requirements.
func (g *GPUToolsClient) filterGPUsByRequirements(gpus []GPUInfo, req GPURequirements) []GPUInfo <span class="cov0" title="0">{
        var candidates []GPUInfo

        for _, gpu := range gpus </span><span class="cov0" title="0">{
                // Check memory requirement
                if req.MinMemoryGB &gt; 0 </span><span class="cov0" title="0">{
                        memoryGB := float64(gpu.MemoryTotal) / 1024.0
                        if memoryGB &lt; req.MinMemoryGB </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Check power draw
                <span class="cov0" title="0">if req.MaxPowerDraw &gt; 0 &amp;&amp; gpu.PowerDraw &gt; req.MaxPowerDraw </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if GPU is available
                <span class="cov0" title="0">if gpu.Status != "available" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check preferred models
                <span class="cov0" title="0">if len(req.PreferredModels) &gt; 0 </span><span class="cov0" title="0">{
                        found := false
                        for _, model := range req.PreferredModels </span><span class="cov0" title="0">{
                                if contains(gpu.Name, model) </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov0" title="0">candidates = append(candidates, gpu)</span>
        }

        <span class="cov0" title="0">return candidates</span>
}

// selectBestGPUs selects the best GPUs from candidates.
func (g *GPUToolsClient) selectBestGPUs(candidates []GPUInfo, req GPURequirements) []GPUInfo <span class="cov0" title="0">{
        if len(candidates) == 0 </span><span class="cov0" title="0">{
                return []GPUInfo{}
        }</span>

        // Sort by memory (descending) and utilization (ascending)
        // For simplicity, just take the first N GPUs
        <span class="cov0" title="0">requiredGPUs := req.RequiredGPUs
        if requiredGPUs == 0 </span><span class="cov0" title="0">{
                requiredGPUs = 1
        }</span>

        <span class="cov0" title="0">if len(candidates) &lt; requiredGPUs </span><span class="cov0" title="0">{
                return candidates
        }</span>

        <span class="cov0" title="0">return candidates[:requiredGPUs]</span>
}

// calculateTotalMemory calculates total memory of selected GPUs.
func (g *GPUToolsClient) calculateTotalMemory(gpus []GPUInfo) int64 <span class="cov0" title="0">{
        var total int64
        for _, gpu := range gpus </span><span class="cov0" title="0">{
                total += gpu.MemoryTotal
        }</span>
        <span class="cov0" title="0">return total</span>
}

// generateSelectionReasoning generates reasoning for GPU selection.
func (g *GPUToolsClient) generateSelectionReasoning(gpus []GPUInfo, req GPURequirements) string <span class="cov0" title="0">{
        if len(gpus) == 0 </span><span class="cov0" title="0">{
                return "No GPUs selected"
        }</span>

        <span class="cov0" title="0">totalMemory := g.calculateTotalMemory(gpus)
        return fmt.Sprintf("Selected %d GPU(s) with total memory %d MB for %s workload",
                len(gpus), totalMemory, req.WorkloadType)</span>
}

// isCUDAVersionCompatible checks CUDA version compatibility.
func (g *GPUToolsClient) isCUDAVersionCompatible(available, required string) bool <span class="cov0" title="0">{
        // Simple version comparison - in practice, this would be more sophisticated
        return available &gt;= required
}</span>

// generateMLEnvironment generates ML environment variables.
func (g *GPUToolsClient) generateMLEnvironment(gpus []GPUInfo, cuda CUDAInfo, config MLEnvironmentConfig) map[string]string <span class="cov0" title="0">{
        env := map[string]string{
                "CUDA_VISIBLE_DEVICES":   g.getGPUIDsString(gpus),
                "NVIDIA_VISIBLE_DEVICES": g.getGPUIDsString(gpus),
                "CUDA_VERSION":           cuda.Version,
        }

        if config.Framework == "pytorch" </span><span class="cov0" title="0">{
                env["PYTORCH_CUDA_ALLOC_CONF"] = "max_split_size_mb:128"
        }</span> else<span class="cov0" title="0"> if config.Framework == "tensorflow" </span><span class="cov0" title="0">{
                env["TF_FORCE_GPU_ALLOW_GROWTH"] = "true"
        }</span>

        <span class="cov0" title="0">return env</span>
}

// generateDockerConfig generates Docker run configuration for GPUs.
func (g *GPUToolsClient) generateDockerConfig(gpus []GPUInfo, config MLEnvironmentConfig) map[string]interface{} <span class="cov0" title="0">{
        gpuConfig := &amp;DockerGPUConfig{
                Enabled:      true,
                Runtime:      "nvidia",
                GPUIDs:       g.getGPUIDs(gpus),
                Capabilities: []string{"compute", "utility"},
        }

        dockerConfig := map[string]interface{}{
                "image":   config.ContainerImage,
                "runtime": "nvidia",
                "gpus":    gpuConfig,
                "env":     g.generateMLEnvironment(gpus, CUDAInfo{}, config),
        }

        if config.WorkspacePath != "" </span><span class="cov0" title="0">{
                dockerConfig["volumes"] = []string{
                        fmt.Sprintf("%s:/workspace", config.WorkspacePath),
                }
        }</span>

        <span class="cov0" title="0">return dockerConfig</span>
}

// generateK8sManifest generates Kubernetes manifest for GPU workloads.
func (g *GPUToolsClient) generateK8sManifest(gpus []GPUInfo, config MLEnvironmentConfig) string <span class="cov0" title="0">{
        gpuCount := len(gpus)

        manifest := fmt.Sprintf(`apiVersion: v1
kind: Pod
metadata:
  name: ml-workload
spec:
  containers:
  - name: ml-container
    image: %s
    resources:
      limits:
        nvidia.com/gpu: %d
      requests:
        nvidia.com/gpu: %d
    env:
    - name: CUDA_VISIBLE_DEVICES
      value: "all"
    - name: NVIDIA_VISIBLE_DEVICES
      value: "all"
  nodeSelector:
    accelerator: nvidia-tesla-gpu
  tolerations:
  - key: nvidia.com/gpu
    operator: Exists
    effect: NoSchedule
`, config.ContainerImage, gpuCount, gpuCount)

        return manifest
}</span>

// generateMonitoringInsights generates insights from monitoring data.
func (g *GPUToolsClient) generateMonitoringInsights(data map[string]interface{}) []string <span class="cov0" title="0">{
        insights := []string{}

        // Analyze samples if available
        if samples, ok := data["samples"].([]map[string]interface{}); ok &amp;&amp; len(samples) &gt; 0 </span><span class="cov0" title="0">{
                insights = append(insights, fmt.Sprintf("Collected %d monitoring samples", len(samples)))

                // Check for high utilization
                for _, sample := range samples </span><span class="cov0" title="0">{
                        if gpus, ok := sample["gpus"].([]GPUInfo); ok </span><span class="cov0" title="0">{
                                for _, gpu := range gpus </span><span class="cov0" title="0">{
                                        if gpu.UtilizationGPU &gt; 90 </span><span class="cov0" title="0">{
                                                insights = append(insights, fmt.Sprintf("GPU %d shows high utilization (%d%%)", gpu.ID, gpu.UtilizationGPU))
                                        }</span>
                                        <span class="cov0" title="0">if gpu.Temperature &gt; 80 </span><span class="cov0" title="0">{
                                                insights = append(insights, fmt.Sprintf("GPU %d temperature is high (%dC)", gpu.ID, gpu.Temperature))
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return insights</span>
}

// Utility functions

// getGPUIDs extracts GPU IDs from GPU info list.
func (g *GPUToolsClient) getGPUIDs(gpus []GPUInfo) []int <span class="cov0" title="0">{
        ids := make([]int, len(gpus))
        for i, gpu := range gpus </span><span class="cov0" title="0">{
                ids[i] = gpu.ID
        }</span>
        <span class="cov0" title="0">return ids</span>
}

// getGPUIDsString returns GPU IDs as comma-separated string.
func (g *GPUToolsClient) getGPUIDsString(gpus []GPUInfo) string <span class="cov0" title="0">{
        if len(gpus) == 0 </span><span class="cov0" title="0">{
                return "all"
        }</span>

        <span class="cov0" title="0">ids := make([]string, len(gpus))
        for i, gpu := range gpus </span><span class="cov0" title="0">{
                ids[i] = fmt.Sprintf("%d", gpu.ID)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%v", ids)</span>
}

// contains checks if a string contains a substring.
func contains(s, substr string) bool <span class="cov0" title="0">{
        return len(s) &gt;= len(substr) &amp;&amp; (s == substr ||
                (len(s) &gt; len(substr) &amp;&amp; (s[:len(substr)] == substr || s[len(s)-len(substr):] == substr ||
                        (len(s) &gt; len(substr) &amp;&amp; s[1:len(substr)+1] == substr))))
}</span>

// uniqueStrings returns unique strings from a slice.
func uniqueStrings(slice []string) []string <span class="cov0" title="0">{
        seen := make(map[string]bool)
        var result []string

        for _, str := range slice </span><span class="cov0" title="0">{
                if !seen[str] </span><span class="cov0" title="0">{
                        seen[str] = true
                        result = append(result, str)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package agentic provides orchestration for multiple infrastructure connectors.
package agentic

import (
        "context"
        "fmt"

        "golang.org/x/xerrors"
)

// Orchestrator manages multiple infrastructure agents and provides unified task execution.
type Orchestrator struct {
        registry      *Registry
        secretManager *SecretManager
        config        *Config
}

// NewOrchestrator creates a new orchestrator with all available connectors.
func NewOrchestrator(config *Config, secretManager *SecretManager) (*Orchestrator, error) <span class="cov0" title="0">{
        registry := NewRegistry()

        // Register LLM/AI connectors
        if config.HuggingFace.APIKey != "" </span><span class="cov0" title="0">{
                hfClient := NewHFClient(config.HuggingFace)
                registry.Register(hfClient)
        }</span>

        <span class="cov0" title="0">if config.IOIntelligence.APIKey != "" </span><span class="cov0" title="0">{
                ioiClient := NewIOIClient(config.IOIntelligence)
                registry.Register(ioiClient)
        }</span>

        // Register OpenCode connector
        <span class="cov0" title="0">if config.OpenCode.APIKey != "" &amp;&amp; config.OpenCode.Endpoint != "" </span><span class="cov0" title="0">{
                opencodeClient := NewOpenCodeClient(config.OpenCode)
                registry.Register(opencodeClient)
        }</span>

        // Register Agent-Zero connector
        <span class="cov0" title="0">if config.AgentZero.Endpoint != "" </span><span class="cov0" title="0">{
                agentZeroClient := NewAgentZeroClient(config.AgentZero)
                registry.Register(agentZeroClient)
        }</span>

        // Register infrastructure connectors

        // Proxmox connector
        <span class="cov0" title="0">if config.Infrastructure.Proxmox.URL != "" </span><span class="cov0" title="0">{
                proxmoxClient := NewProxmoxClient(config.Infrastructure.Proxmox)
                registry.Register(proxmoxClient)
        }</span>

        // Docker connector
        <span class="cov0" title="0">dockerClient := NewDockerClient(config.Infrastructure.Docker)
        registry.Register(dockerClient)

        // Kubernetes connector
        kubernetesClient := NewKubernetesClient(config.Infrastructure.Kubernetes)
        registry.Register(kubernetesClient)

        // Nix connector
        nixClient := NewNixClient(config.Infrastructure.Nix)
        registry.Register(nixClient)

        // GPU connector
        gpuClient := NewGPUClient(config.Infrastructure.GPU)
        registry.Register(gpuClient)

        return &amp;Orchestrator{
                registry:      registry,
                secretManager: secretManager,
                config:        config,
        }, nil</span>
}

// ExecuteTask executes a task using the appropriate connector.
func (o *Orchestrator) ExecuteTask(ctx context.Context, task *Task) (*TaskResult, error) <span class="cov0" title="0">{
        agent, err := o.registry.Select(task.Type)
        if err != nil </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("no agent available for task type '%s': %w", task.Type, err)
        }</span>

        <span class="cov0" title="0">return agent.Execute(ctx, task)</span>
}

// ListConnectors returns information about available connectors.
func (o *Orchestrator) ListConnectors() []ConnectorInfo <span class="cov0" title="0">{
        var connectors []ConnectorInfo

        // Check each registered agent
        for _, agent := range o.registry.agents </span><span class="cov0" title="0">{
                connector := ConnectorInfo{
                        Name:           agent.Name(),
                        Type:           getConnectorType(agent),
                        Status:         "available",
                        SupportedTasks: getSupportedTasks(agent),
                }
                connectors = append(connectors, connector)
        }</span>

        <span class="cov0" title="0">return connectors</span>
}

// ConnectorInfo provides information about a connector.
type ConnectorInfo struct {
        Name           string   `json:"name"`
        Type           string   `json:"type"`   // "llm", "infrastructure", "cloud"
        Status         string   `json:"status"` // "available", "configured", "error"
        SupportedTasks []string `json:"supported_tasks"`
}

// getConnectorType determines the type of a connector.
func getConnectorType(agent Agent) string <span class="cov0" title="0">{
        switch agent.Name() </span>{
        case "huggingface", "io_intelligence":<span class="cov0" title="0">
                return "llm"</span>
        case "proxmox", "docker", "kubernetes", "nix", "gpu":<span class="cov0" title="0">
                return "infrastructure"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// getSupportedTasks returns the task types supported by an agent.
func getSupportedTasks(agent Agent) []string <span class="cov0" title="0">{
        var tasks []string

        // Test common task types
        testTasks := []string{
                "llm", "embedding",
                "vm", "container", "infrastructure",
                "kubernetes", "k8s", "cluster",
                "docker", "podman",
                "nix", "nixos", "flake", "reproducible",
                "gpu", "nvidia", "cuda", "hardware",
        }

        for _, taskType := range testTasks </span><span class="cov0" title="0">{
                if agent.Supports(taskType) </span><span class="cov0" title="0">{
                        tasks = append(tasks, taskType)
                }</span>
        }

        <span class="cov0" title="0">return tasks</span>
}

// ExecuteInfrastructureWorkflow executes a complex infrastructure workflow.
func (o *Orchestrator) ExecuteInfrastructureWorkflow(ctx context.Context, workflow *InfrastructureWorkflow) (*WorkflowResult, error) <span class="cov0" title="0">{
        result := &amp;WorkflowResult{
                WorkflowID: workflow.ID,
                Steps:      make([]StepResult, 0, len(workflow.Steps)),
        }

        for i, step := range workflow.Steps </span><span class="cov0" title="0">{
                stepResult := StepResult{
                        StepID: step.ID,
                        Name:   step.Name,
                        Order:  i + 1,
                }

                // Execute the step
                task := &amp;Task{
                        Type:    step.TaskType,
                        Payload: step.Parameters,
                }

                taskResult, err := o.ExecuteTask(ctx, task)
                if err != nil </span><span class="cov0" title="0">{
                        stepResult.Status = "failed"
                        stepResult.Error = err.Error()
                        result.Steps = append(result.Steps, stepResult)
                        result.Status = "failed"
                        return result, xerrors.Errorf("workflow step %d failed: %w", i+1, err)
                }</span>

                <span class="cov0" title="0">stepResult.Status = "completed"
                stepResult.Output = taskResult.Output
                result.Steps = append(result.Steps, stepResult)

                // Check if we should continue on error
                if taskResult.Error != nil &amp;&amp; !step.ContinueOnError </span><span class="cov0" title="0">{
                        result.Status = "failed"
                        return result, xerrors.Errorf("workflow step %d had error: %w", i+1, taskResult.Error)
                }</span>
        }

        <span class="cov0" title="0">result.Status = "completed"
        return result, nil</span>
}

// InfrastructureWorkflow represents a complex infrastructure automation workflow.
type InfrastructureWorkflow struct {
        ID          string         `json:"id"`
        Name        string         `json:"name"`
        Description string         `json:"description"`
        Steps       []WorkflowStep `json:"steps"`
}

// WorkflowStep represents a single step in a workflow.
type WorkflowStep struct {
        ID              string                 `json:"id"`
        Name            string                 `json:"name"`
        TaskType        string                 `json:"task_type"` // vm, container, kubernetes, etc.
        Parameters      map[string]interface{} `json:"parameters"`
        DependsOn       []string               `json:"depends_on"` // Step IDs this step depends on
        ContinueOnError bool                   `json:"continue_on_error"`
}

// WorkflowResult represents the result of a workflow execution.
type WorkflowResult struct {
        WorkflowID string       `json:"workflow_id"`
        Status     string       `json:"status"` // "running", "completed", "failed"
        Steps      []StepResult `json:"steps"`
}

// StepResult represents the result of a single workflow step.
type StepResult struct {
        StepID string      `json:"step_id"`
        Name   string      `json:"name"`
        Order  int         `json:"order"`
        Status string      `json:"status"` // "pending", "running", "completed", "failed"
        Output interface{} `json:"output,omitempty"`
        Error  string      `json:"error,omitempty"`
}

// CreateVMWorkflow creates a workflow for provisioning a complete VM infrastructure.
func CreateVMWorkflow(vmConfig VMWorkflowConfig) *InfrastructureWorkflow <span class="cov0" title="0">{
        workflow := &amp;InfrastructureWorkflow{
                ID:          fmt.Sprintf("vm-provision-%s", vmConfig.Name),
                Name:        fmt.Sprintf("Provision VM: %s", vmConfig.Name),
                Description: "Complete VM provisioning workflow with container setup",
                Steps:       []WorkflowStep{},
        }

        // Step 1: Create VM in Proxmox
        if vmConfig.UseProxmox </span><span class="cov0" title="0">{
                workflow.Steps = append(workflow.Steps, WorkflowStep{
                        ID:       "create-vm",
                        Name:     "Create Virtual Machine",
                        TaskType: "vm",
                        Parameters: map[string]interface{}{
                                "action":  "create",
                                "vm_type": "qemu",
                                "node":    vmConfig.ProxmoxNode,
                                "config": map[string]interface{}{
                                        "cores":  vmConfig.CPU,
                                        "memory": vmConfig.Memory,
                                        "scsihw": "virtio-scsi-pci",
                                        "net0":   "virtio,bridge=vmbr0",
                                },
                        },
                })
        }</span>

        // Step 2: Start VM
        <span class="cov0" title="0">if vmConfig.UseProxmox </span><span class="cov0" title="0">{
                workflow.Steps = append(workflow.Steps, WorkflowStep{
                        ID:        "start-vm",
                        Name:      "Start Virtual Machine",
                        TaskType:  "vm",
                        DependsOn: []string{"create-vm"},
                        Parameters: map[string]interface{}{
                                "action":  "start",
                                "vm_type": "qemu",
                                "node":    vmConfig.ProxmoxNode,
                                "vmid":    vmConfig.VMID,
                        },
                })
        }</span>

        // Step 3: Setup Docker containers
        <span class="cov0" title="0">if len(vmConfig.Containers) &gt; 0 </span><span class="cov0" title="0">{
                for i, container := range vmConfig.Containers </span><span class="cov0" title="0">{
                        stepID := fmt.Sprintf("deploy-container-%d", i+1)
                        dependsOn := []string{}
                        if vmConfig.UseProxmox </span><span class="cov0" title="0">{
                                dependsOn = []string{"start-vm"}
                        }</span>

                        <span class="cov0" title="0">workflow.Steps = append(workflow.Steps, WorkflowStep{
                                ID:        stepID,
                                Name:      fmt.Sprintf("Deploy Container: %s", container.Name),
                                TaskType:  "container",
                                DependsOn: dependsOn,
                                Parameters: map[string]interface{}{
                                        "action":  "run",
                                        "image":   container.Image,
                                        "name":    container.Name,
                                        "ports":   container.Ports,
                                        "volumes": container.Volumes,
                                        "env":     container.Environment,
                                        "detach":  true,
                                },
                        })</span>
                }
        }

        // Step 4: Deploy Kubernetes resources
        <span class="cov0" title="0">if len(vmConfig.KubernetesManifests) &gt; 0 </span><span class="cov0" title="0">{
                for i, manifest := range vmConfig.KubernetesManifests </span><span class="cov0" title="0">{
                        stepID := fmt.Sprintf("deploy-k8s-%d", i+1)

                        workflow.Steps = append(workflow.Steps, WorkflowStep{
                                ID:       stepID,
                                Name:     fmt.Sprintf("Deploy K8s: %s", manifest.Name),
                                TaskType: "kubernetes",
                                Parameters: map[string]interface{}{
                                        "action":    "apply",
                                        "manifest":  manifest.YAML,
                                        "namespace": manifest.Namespace,
                                },
                        })
                }</span>
        }

        <span class="cov0" title="0">return workflow</span>
}

// VMWorkflowConfig represents configuration for a VM provisioning workflow.
type VMWorkflowConfig struct {
        Name        string `json:"name"`
        VMID        int    `json:"vmid"`
        CPU         int    `json:"cpu"`
        Memory      int    `json:"memory"`
        UseProxmox  bool   `json:"use_proxmox"`
        ProxmoxNode string `json:"proxmox_node"`

        // Container configuration
        Containers []ContainerConfig `json:"containers"`

        // Kubernetes configuration
        KubernetesManifests []K8sManifestConfig `json:"kubernetes_manifests"`
}

// ContainerConfig represents a container to deploy.
type ContainerConfig struct {
        Name        string            `json:"name"`
        Image       string            `json:"image"`
        Ports       []string          `json:"ports"`
        Volumes     []string          `json:"volumes"`
        Environment map[string]string `json:"environment"`
}

// K8sManifestConfig represents a Kubernetes manifest to deploy.
type K8sManifestConfig struct {
        Name      string `json:"name"`
        Namespace string `json:"namespace"`
        YAML      string `json:"yaml"`
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package agentic provides secure secrets management for the agentic orchestration system.
package agentic

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "io"
        "os"
        "path/filepath"
        "strings"

        "golang.org/x/crypto/pbkdf2"
        "golang.org/x/xerrors"
)

// SecretStore manages encrypted secrets for API keys, credentials, etc.
type SecretStore interface {
        Set(key, value string) error
        Get(key string) (string, error)
        Delete(key string) error
        List() ([]string, error)
}

// EnvSecretStore implements SecretStore using environment variables.
type EnvSecretStore struct{}

func NewEnvSecretStore() *EnvSecretStore <span class="cov0" title="0">{
        return &amp;EnvSecretStore{}
}</span>

func (e *EnvSecretStore) Set(key, value string) error <span class="cov0" title="0">{
        return os.Setenv(key, value)
}</span>

func (e *EnvSecretStore) Get(key string) (string, error) <span class="cov0" title="0">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov0" title="0">{
                return "", xerrors.New("secret not found")
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}

func (e *EnvSecretStore) Delete(key string) error <span class="cov0" title="0">{
        return os.Unsetenv(key)
}</span>

func (e *EnvSecretStore) List() ([]string, error) <span class="cov0" title="0">{
        env := os.Environ()
        keys := make([]string, 0, len(env))
        for _, pair := range env </span><span class="cov0" title="0">{
                key := strings.SplitN(pair, "=", 2)[0]
                keys = append(keys, key)
        }</span>
        <span class="cov0" title="0">return keys, nil</span>
}

// FileSecretStore implements SecretStore using encrypted local files.
type FileSecretStore struct {
        filePath string
        password string
}

type encryptedSecrets struct {
        Salt    string            `json:"salt"`
        Nonce   string            `json:"nonce"`
        Data    string            `json:"data"`
        Secrets map[string]string `json:"-"` // Decrypted data
}

func NewFileSecretStore(filePath, password string) *FileSecretStore <span class="cov0" title="0">{
        return &amp;FileSecretStore{
                filePath: filePath,
                password: password,
        }
}</span>

func (f *FileSecretStore) deriveKey(salt []byte) []byte <span class="cov0" title="0">{
        return pbkdf2.Key([]byte(f.password), salt, 4096, 32, sha256.New)
}</span>

func (f *FileSecretStore) loadSecrets() (*encryptedSecrets, error) <span class="cov0" title="0">{
        if _, err := os.Stat(f.filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return &amp;encryptedSecrets{Secrets: make(map[string]string)}, nil
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile(f.filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var secrets encryptedSecrets
        if err := json.Unmarshal(data, &amp;secrets); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Decrypt the data
        <span class="cov0" title="0">salt, err := base64.StdEncoding.DecodeString(secrets.Salt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">nonce, err := base64.StdEncoding.DecodeString(secrets.Nonce)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ciphertext, err := base64.StdEncoding.DecodeString(secrets.Data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">key := f.deriveKey(salt)
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">aesGCM, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">plaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">secrets.Secrets = make(map[string]string)
        if err := json.Unmarshal(plaintext, &amp;secrets.Secrets); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;secrets, nil</span>
}

func (f *FileSecretStore) saveSecrets(secrets *encryptedSecrets) error <span class="cov0" title="0">{
        // Create directory if it doesn't exist
        if err := os.MkdirAll(filepath.Dir(f.filePath), 0700); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Encrypt the secrets
        <span class="cov0" title="0">plaintext, err := json.Marshal(secrets.Secrets)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">salt := make([]byte, 16)
        if _, err := io.ReadFull(rand.Reader, salt); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">key := f.deriveKey(salt)
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">aesGCM, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">nonce := make([]byte, aesGCM.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ciphertext := aesGCM.Seal(nil, nonce, plaintext, nil)

        secrets.Salt = base64.StdEncoding.EncodeToString(salt)
        secrets.Nonce = base64.StdEncoding.EncodeToString(nonce)
        secrets.Data = base64.StdEncoding.EncodeToString(ciphertext)

        data, err := json.MarshalIndent(secrets, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(f.filePath, data, 0600)</span>
}

func (f *FileSecretStore) Set(key, value string) error <span class="cov0" title="0">{
        secrets, err := f.loadSecrets()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">secrets.Secrets[key] = value
        return f.saveSecrets(secrets)</span>
}

func (f *FileSecretStore) Get(key string) (string, error) <span class="cov0" title="0">{
        secrets, err := f.loadSecrets()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">value, exists := secrets.Secrets[key]
        if !exists </span><span class="cov0" title="0">{
                return "", xerrors.New("secret not found")
        }</span>

        <span class="cov0" title="0">return value, nil</span>
}

func (f *FileSecretStore) Delete(key string) error <span class="cov0" title="0">{
        secrets, err := f.loadSecrets()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">delete(secrets.Secrets, key)
        return f.saveSecrets(secrets)</span>
}

func (f *FileSecretStore) List() ([]string, error) <span class="cov0" title="0">{
        secrets, err := f.loadSecrets()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">keys := make([]string, 0, len(secrets.Secrets))
        for key := range secrets.Secrets </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>

        <span class="cov0" title="0">return keys, nil</span>
}

// SecretManager provides a unified interface for multiple secret stores.
type SecretManager struct {
        stores map[string]SecretStore
        logger func(string, ...interface{}) // Optional logger
}

func NewSecretManager() *SecretManager <span class="cov0" title="0">{
        return &amp;SecretManager{
                stores: make(map[string]SecretStore),
        }
}</span>

func (sm *SecretManager) SetLogger(logger func(string, ...interface{})) <span class="cov0" title="0">{
        sm.logger = logger
}</span>

func (sm *SecretManager) AddStore(name string, store SecretStore) <span class="cov0" title="0">{
        sm.stores[name] = store
}</span>

func (sm *SecretManager) Get(key string) (string, error) <span class="cov0" title="0">{
        // Try environment variables first
        if envStore, exists := sm.stores["env"]; exists </span><span class="cov0" title="0">{
                if value, err := envStore.Get(key); err == nil </span><span class="cov0" title="0">{
                        return value, nil
                }</span>
        }

        // Try other stores
        <span class="cov0" title="0">for name, store := range sm.stores </span><span class="cov0" title="0">{
                if name == "env" </span><span class="cov0" title="0">{
                        continue</span> // Already tried
                }
                <span class="cov0" title="0">if value, err := store.Get(key); err == nil </span><span class="cov0" title="0">{
                        return value, nil
                }</span>
        }

        <span class="cov0" title="0">return "", xerrors.Errorf("secret '%s' not found in any store", key)</span>
}

func (sm *SecretManager) Set(storeName, key, value string) error <span class="cov0" title="0">{
        store, exists := sm.stores[storeName]
        if !exists </span><span class="cov0" title="0">{
                return xerrors.Errorf("store '%s' not found", storeName)
        }</span>

        // Never log secret values
        <span class="cov0" title="0">if sm.logger != nil </span><span class="cov0" title="0">{
                sm.logger("Setting secret key '%s' in store '%s'", key, storeName)
        }</span>

        <span class="cov0" title="0">return store.Set(key, value)</span>
}

func (sm *SecretManager) Delete(storeName, key string) error <span class="cov0" title="0">{
        store, exists := sm.stores[storeName]
        if !exists </span><span class="cov0" title="0">{
                return xerrors.Errorf("store '%s' not found", storeName)
        }</span>

        <span class="cov0" title="0">if sm.logger != nil </span><span class="cov0" title="0">{
                sm.logger("Deleting secret key '%s' from store '%s'", key, storeName)
        }</span>

        <span class="cov0" title="0">return store.Delete(key)</span>
}

// GetCredentials retrieves common credential sets safely.
func (sm *SecretManager) GetCredentials(service string) (map[string]string, error) <span class="cov0" title="0">{
        creds := make(map[string]string)

        switch service </span>{
        case "github":<span class="cov0" title="0">
                if clientID, err := sm.Get("GITHUB_CLIENT_ID"); err == nil </span><span class="cov0" title="0">{
                        creds["client_id"] = clientID
                }</span>
                <span class="cov0" title="0">if clientSecret, err := sm.Get("GITHUB_CLIENT_SECRET"); err == nil </span><span class="cov0" title="0">{
                        creds["client_secret"] = clientSecret
                }</span>
                <span class="cov0" title="0">if token, err := sm.Get("GITHUB_TOKEN"); err == nil </span><span class="cov0" title="0">{
                        creds["token"] = token
                }</span>

        case "proxmox":<span class="cov0" title="0">
                if url, err := sm.Get("PROXMOX_URL"); err == nil </span><span class="cov0" title="0">{
                        creds["url"] = url
                }</span>
                <span class="cov0" title="0">if username, err := sm.Get("PROXMOX_USERNAME"); err == nil </span><span class="cov0" title="0">{
                        creds["username"] = username
                }</span>
                <span class="cov0" title="0">if password, err := sm.Get("PROXMOX_PASSWORD"); err == nil </span><span class="cov0" title="0">{
                        creds["password"] = password
                }</span>
                <span class="cov0" title="0">if token, err := sm.Get("PROXMOX_TOKEN"); err == nil </span><span class="cov0" title="0">{
                        creds["token"] = token
                }</span>

        case "cloudflare":<span class="cov0" title="0">
                if apiKey, err := sm.Get("CLOUDFLARE_API_KEY"); err == nil </span><span class="cov0" title="0">{
                        creds["api_key"] = apiKey
                }</span>
                <span class="cov0" title="0">if email, err := sm.Get("CLOUDFLARE_EMAIL"); err == nil </span><span class="cov0" title="0">{
                        creds["email"] = email
                }</span>
                <span class="cov0" title="0">if token, err := sm.Get("CLOUDFLARE_TOKEN"); err == nil </span><span class="cov0" title="0">{
                        creds["token"] = token
                }</span>

        case "nix":<span class="cov0" title="0">
                if nixPath, err := sm.Get("NIX_PATH"); err == nil </span><span class="cov0" title="0">{
                        creds["nix_path"] = nixPath
                }</span>
                <span class="cov0" title="0">if signingKey, err := sm.Get("NIX_SIGNING_KEY"); err == nil </span><span class="cov0" title="0">{
                        creds["signing_key"] = signingKey
                }</span>
                <span class="cov0" title="0">if substitutes, err := sm.Get("NIX_SUBSTITUTES"); err == nil </span><span class="cov0" title="0">{
                        creds["substitutes"] = substitutes
                }</span>
                <span class="cov0" title="0">if trustedKeys, err := sm.Get("NIX_TRUSTED_KEYS"); err == nil </span><span class="cov0" title="0">{
                        creds["trusted_keys"] = trustedKeys
                }</span>
                <span class="cov0" title="0">if remoteHosts, err := sm.Get("NIX_REMOTE_HOSTS"); err == nil </span><span class="cov0" title="0">{
                        creds["remote_hosts"] = remoteHosts
                }</span>

        default:<span class="cov0" title="0">
                return nil, xerrors.Errorf("unknown service: %s", service)</span>
        }

        <span class="cov0" title="0">if len(creds) == 0 </span><span class="cov0" title="0">{
                return nil, xerrors.Errorf("no credentials found for service: %s", service)
        }</span>

        <span class="cov0" title="0">return creds, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package agentic provides task/job definitions and a background scheduler.
package agentic

import (
        "context"
        "sync"
)

// Task represents a unit of work for an agent.
type Task struct {
        Type    string
        Payload map[string]interface{}
        Status  string
        Result  *TaskResult
}

// TaskResult holds the result of a completed task.
type TaskResult struct {
        Output interface{}
        Error  error
}

// Scheduler manages task queueing and background execution.
type Scheduler struct {
        queue    chan *Task
        registry *Registry
        wg       sync.WaitGroup
        ctx      context.Context
        cancel   context.CancelFunc
}

// NewScheduler creates a new Scheduler.
func NewScheduler(registry *Registry, queueSize int) *Scheduler <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        return &amp;Scheduler{
                queue:    make(chan *Task, queueSize),
                registry: registry,
                ctx:      ctx,
                cancel:   cancel,
        }
}</span>

// Schedule adds a task to the queue.
func (s *Scheduler) Schedule(task *Task) <span class="cov0" title="0">{
        s.queue &lt;- task
}</span>

// Run starts background workers.
func (s *Scheduler) Run(workers int) <span class="cov0" title="0">{
        for i := 0; i &lt; workers; i++ </span><span class="cov0" title="0">{
                s.wg.Add(1)
                go s.worker()
        }</span>
}

// Stop signals all workers to stop and waits for them.
func (s *Scheduler) Stop() <span class="cov0" title="0">{
        s.cancel()
        close(s.queue)
        s.wg.Wait()
}</span>

func (s *Scheduler) worker() <span class="cov0" title="0">{
        defer s.wg.Done()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-s.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case task, ok := &lt;-s.queue:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">s.handleTask(task)</span>
                }
        }
}

func (s *Scheduler) handleTask(task *Task) <span class="cov0" title="0">{
        agent, err := s.registry.Select(task.Type)
        if err != nil </span><span class="cov0" title="0">{
                task.Status = "failed"
                task.Result = &amp;TaskResult{Error: err}
                return
        }</span>
        <span class="cov0" title="0">task.Status = "running"
        res, err := agent.Execute(s.ctx, task)
        task.Status = "done"
        task.Result = res
        if err != nil </span><span class="cov0" title="0">{
                task.Result.Error = err
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
