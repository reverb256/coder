package cli

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/cli/safeexec"
	"github.com/coder/coder/cli/clog"
	"github.com/spf13/cobra"
	"golang.org/x/xerrors"
)

const sshStartToken = "# ------------START-CODER-----------"
const sshStartMessage = `# This was generated by "coder config-ssh".
#
# To remove this blob, run:
#
#    coder config-ssh --remove
#
# You should not hand-edit this section, unless you are deleting it.`
const sshEndToken = "# ------------END-CODER------------"

func configSSH() *cobra.Command {
	cmd := &cobra.Command{
		Use: "config-ssh",
		RunE: func(cmd *cobra.Command, args []string) error {
			binPath(cmd.OutOrStdout())

			return nil
		},
	}

	return cmd
}

// removeOldConfig removes the old ssh configuration from the user's sshconfig.
// Returns true if the config was modified.
func removeOldConfig(config string) (string, bool) {
	startIndex := strings.Index(config, sshStartToken)
	endIndex := strings.Index(config, sshEndToken)

	if startIndex == -1 || endIndex == -1 {
		return config, false
	}
	if startIndex == 0 {
		return config[endIndex+len(sshEndToken)+1:], true
	}
	return config[:startIndex-1] + config[endIndex+len(sshEndToken)+1:], true
}

func makeSSHConfig(userID, binPath, workspaceName, privateKeyFilepath string, additionalOptions []string) string {
	// Custom user options come first to maximizessh customization.
	options := []string{}
	if len(additionalOptions) > 0 {
		options = []string{
			"# Custom options. Duplicated values will always prefer the first!",
		}
		options = append(options, additionalOptions...)
		options = append(options, "# End custom options.")
	}
	options = append(options,
		fmt.Sprintf("HostName coder.%s", workspaceName),
		fmt.Sprintf("ProxyCommand %s", fmt.Sprintf(`"%s" ssh %s`, binPath, workspaceName)),
		"StrictHostKeyChecking no",
		"ConnectTimeout=0",
		"IdentitiesOnly yes",
		fmt.Sprintf("IdentityFile=%q", privateKeyFilepath),
	)

	return fmt.Sprintf("Host coder.%s\n\t%s\n\n", workspaceName, strings.Join(options, "\n\t"))
}

// binPath returns the path to the coder binary suitable for use in ssh ProxyCommand.
func binPath(logWriter io.Writer) (string, error) {
	exePath, err := os.Executable()
	if err != nil {
		return "", xerrors.Errorf("get executable path: %w", err)
	}

	// On Windows, the coder-cli executable must be in $PATH for both Msys2/Git
	// Bash and OpenSSH for Windows (used by Powershell and VS Code) to function
	// correctly. Check if the current executable is in $PATH, and warn the user
	// if it isn't.
	if runtime.GOOS == goosWindows {
		binName := filepath.Base(exePath)

		// We use safeexec instead of os/exec because os/exec returns paths in
		// the current working directory, which we will run into very often when
		// looking for our own path.
		pathPath, err := safeexec.LookPath(binName)
		if err != nil {
			clog.LogWarn(logWriter,
				"The current executable is not in $PATH.",
				"This may lead to problems connecting to your workspace via SSH.",
				fmt.Sprintf("Please move %q to a location in your $PATH (such as System32) and run `%s config-ssh` again.", binName, binName),
			)
			// Return the exePath so SSH at least works outside of Msys2.
			return exePath, nil
		}

		// Warn the user if the current executable is not the same as the one in
		// $PATH.
		if filepath.Clean(pathPath) != filepath.Clean(exePath) {
			clog.LogWarn(logWriter,
				"The current executable path does not match the executable path found in $PATH.",
				"This may lead to problems connecting to your workspace via SSH.",
				fmt.Sprintf("\t Current executable path: %q", exePath),
				fmt.Sprintf("\tExecutable path in $PATH: %q", pathPath),
			)
		}

		return binName, nil
	}

	// On platforms other than Windows we can use the full path to the binary.
	return exePath, nil
}
